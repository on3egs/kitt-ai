<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#0a0a0a">
<link rel="manifest" href="/static/manifest.json">
<title>KITT — Knight Industries Two Thousand</title>
<meta name="author" content="ByManix (Emmanuel Gelinne)">
<meta name="license" content="Elastic License 2.0">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html { height: 100%; overflow: hidden; }
body {
  background: radial-gradient(ellipse at 50% 30%, #0f0000 0%, #050000 40%, #020000 100%);
  color: #e0e0e0;
  font-family: 'Courier New', monospace;
  position: fixed;
  top: 0; left: 0; right: 0;
  height: 100dvh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}
/* Effet grille CRT subtil en arrière-plan */
body::before {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background-image:
    linear-gradient(rgba(0,180,60,0.012) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,0,0,0.012) 1px, transparent 1px);
  background-size: 40px 40px;
  pointer-events: none;
  z-index: 0;
}
body::after {
  content: '';
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.06) 2px,
    rgba(0,0,0,0.06) 4px
  );
  pointer-events: none;
  z-index: 0;
}
body > * { position: relative; z-index: 1; }

/* Header */
.header {
  text-align: center;
  padding: 12px 15px 10px;
  border-bottom: 1px solid #1e0000;
  background: linear-gradient(180deg, #0f0000 0%, transparent 100%);
  position: relative;
  flex-shrink: 0;
  z-index: 5;
}
.header::after {
  content: '';
  position: absolute;
  bottom: 0; left: 10%; right: 10%;
  height: 1px;
  background: linear-gradient(90deg, transparent, #ff2200, #ff5500, #ff2200, transparent);
  box-shadow: 0 0 8px #ff220066;
}
.header h1 {
  font-size: 1.6em;
  color: #ff3333;
  text-shadow: 0 0 25px #ff0000, 0 0 50px #ff000044;
  letter-spacing: 8px;
  font-weight: bold;
  animation: header-glow 5s ease-in-out infinite;
}
@keyframes header-glow {
  0%,100% { text-shadow: 0 0 25px #ff0000, 0 0 50px #ff000044; }
  50%      { text-shadow: 0 0 35px #ff2200, 0 0 70px #ff000055; }
}
.header .subtitle {
  font-size: 0.62em;
  color: #886655;
  margin-top: 5px;
  padding-top: 4px;
  border-top: 1px solid #150500;
  letter-spacing: 2px;
  text-transform: uppercase;
}
.footer-credit {
  text-align: center;
  padding: 5px;
  font-size: 0.52em;
  color: #664444;
  letter-spacing: 1px;
  border-top: 1px solid #110000;
  background: linear-gradient(0deg, #0a0000 0%, transparent 100%);
  cursor: pointer;
  -webkit-user-select: none;
  user-select: none;
}
.footer-credit:active { color: #664444; }

/* About overlay */
.about-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.92);
  z-index: 100;
  justify-content: center;
  align-items: center;
  padding: 20px;
}
.about-overlay.visible { display: flex; }
.about-box {
  max-width: 360px;
  width: 100%;
  border: 1px solid #331111;
  border-radius: 10px;
  padding: 28px 24px;
  background: #0d0d0d;
  text-align: center;
  font-size: 0.8em;
  line-height: 1.7;
  color: #888;
}
.about-box .about-title {
  font-size: 1.4em;
  color: #ff3333;
  text-shadow: 0 0 15px #ff000066;
  letter-spacing: 3px;
  margin-bottom: 4px;
}
.about-box .about-sub {
  font-size: 0.6em;
  color: #444;
  letter-spacing: 1px;
  margin-bottom: 16px;
}
.about-box .about-dev {
  color: #666;
  font-size: 0.85em;
  margin-top: 12px;
}
.about-box .about-license {
  color: #443333;
  font-size: 0.7em;
  margin-top: 10px;
}
.about-box .about-close {
  color: #333;
  font-size: 0.65em;
  margin-top: 18px;
}

/* Mobile responsive */
@media (max-width: 480px) {
  .header { padding: 10px; }
  .header h1 { font-size: 1.2em; letter-spacing: 3px; }
  .scanner-container { padding: 12px; }
  .chat-area { padding: 10px; }
  .input-area { padding: 10px 10px max(10px, env(safe-area-inset-bottom)); gap: 6px; }
  .input-area input { padding: 10px; font-size: 16px; }
  .input-area button { padding: 10px 14px; font-size: 0.85em; }
  .message { font-size: 0.85em; max-width: 90%; }
  .mic-btn, .auto-btn, .wake-btn, .cam-btn, .audio-btn {
    width: 48px !important; height: 48px !important;
    min-width: 48px; flex-shrink: 0;
  }
  /* Zone tactile 44px minimum pour les boutons header (RST/AMB/VIG/NIGHT/VIS/RPT/AUTO) */
  /* position:relative obligatoire pour que ::before absolu soit ancré sur le bouton */
  .reset-btn, .ambient-btn, .vig-btn, .night-btn, .vis-btn, .rpt-btn, .enhance-btn {
    position: relative;
  }
  .reset-btn::before, .ambient-btn::before, .vig-btn::before, .night-btn::before,
  .vis-btn::before, .rpt-btn::before, .enhance-btn::before {
    content: '';
    position: absolute;
    top: -12px; bottom: -12px;
    left: -10px; right: -10px;
  }
}

/* ── Dock KITT mobile — clavier ouvert ───────────────────────── */
@media (max-width: 700px) {
  /* Quand le clavier virtuel est détecté */
  body.keyboard-open .scanner-container { display: none; }
  body.keyboard-open .mobile-stats { display: none; }
  body.keyboard-open .header .subtitle { display: none; }
  body.keyboard-open .header .mother-line { display: none; }
  body.keyboard-open .header-btns { display: none; }
  body.keyboard-open .header { padding: 6px 10px; min-height: unset; }

  /* Barre input ancrée au clavier — style KITT dock */
  body.keyboard-open .input-area {
    background: #060606;
    border-top: 2px solid #550000;
    box-shadow: 0 -8px 30px #ff000020, 0 -2px 0 #330000;
    padding-top: 10px;
    padding-bottom: max(10px, env(safe-area-inset-bottom));
  }
  body.keyboard-open .input-area input {
    border-color: #550000;
    border-bottom-color: #880000;
    background: #0d0000;
    font-size: 16px;
  }
  body.keyboard-open .input-area input:focus {
    border-color: #990000;
    border-bottom-color: #cc2200;
    box-shadow: 0 2px 16px #ff000033, inset 0 0 12px #ff000012;
    color: #ffcccc;
  }
  /* Ligne décorative KITT au-dessus du dock */
  body.keyboard-open .input-area::before {
    background: linear-gradient(90deg, transparent, #880000, #ff2200, #880000, transparent);
    opacity: 0.8;
  }
}

/* Scanner */
.scanner-container {
  display: none;
}
.scanner {
  width: min(300px, 80vw);
  height: 8px;
  background: #1a0000;
  border-radius: 4px;
  position: relative;
  overflow: hidden;
  border: 1px solid #330000;
}
/* Scanner KI2000 — géré par JS rAF (scanner-head + scanner-trail) */
.scanner-trail {
  position: absolute; top: 0; height: 100%;
  width: 80px; border-radius: 4px; pointer-events: none;
}
.scanner-head {
  position: absolute; top: -2px; width: 28px;
  height: calc(100% + 4px); border-radius: 6px; pointer-events: none;
}

/* Chat area */
.chat-area {
  flex: 1;
  overflow-y: auto;
  padding: 14px 16px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  scrollbar-width: thin;
  scrollbar-color: #cc2200 #080000;
  scrollbar-gutter: stable;
  box-shadow:
    inset 0 0 40px rgba(160,0,0,0.04),
    inset 0 10px 20px rgba(0,0,0,0.25),
    inset 0 -10px 20px rgba(0,0,0,0.25);
}
.chat-area::-webkit-scrollbar { width: 5px; }
.chat-area::-webkit-scrollbar-track { background: #050000; border-radius: 3px; }
.chat-area::-webkit-scrollbar-thumb {
  background: linear-gradient(180deg, #881100 0%, #cc2200 50%, #881100 100%);
  border-radius: 3px;
}
.chat-area::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(180deg, #bb2200 0%, #ff3300 50%, #bb2200 100%);
  box-shadow: 0 0 6px rgba(255,40,0,0.5);
}

.message {
  max-width: 84%;
  padding: 11px 16px 10px;
  border-radius: 4px;
  font-size: 0.88em;
  line-height: 1.5;
  position: relative;
  animation: msgAppear 0.42s cubic-bezier(0.34,1.56,0.64,1) both;
  -webkit-animation: msgAppear 0.42s cubic-bezier(0.34,1.56,0.64,1) both;
}
@keyframes msgAppear {
  from { opacity: 0; transform: translateY(10px) scale(0.96); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}
@keyframes msgAppearLeft {
  from { opacity: 0; transform: translate(-14px, 4px) scale(0.96); }
  to   { opacity: 1; transform: translate(0, 0) scale(1); }
}
@keyframes msgAppearRight {
  from { opacity: 0; transform: translate(14px, 4px) scale(0.96); }
  to   { opacity: 1; transform: translate(0, 0) scale(1); }
}
@-webkit-keyframes msgAppear {
  from { opacity: 0; -webkit-transform: translateY(10px) scale(0.96); }
  to   { opacity: 1; -webkit-transform: translateY(0) scale(1); }
}
@-webkit-keyframes msgAppearLeft {
  from { opacity: 0; -webkit-transform: translate(-14px, 4px) scale(0.96); }
  to   { opacity: 1; -webkit-transform: translate(0, 0) scale(1); }
}
@-webkit-keyframes msgAppearRight {
  from { opacity: 0; -webkit-transform: translate(14px, 4px) scale(0.96); }
  to   { opacity: 1; -webkit-transform: translate(0, 0) scale(1); }
}
.message.kitt, .message.proactive {
  animation-name: msgAppearLeft;
  -webkit-animation-name: msgAppearLeft;
}
.message.user {
  animation-name: msgAppearRight;
  -webkit-animation-name: msgAppearRight;
}
.message::before {
  font-size: 0.6em;
  letter-spacing: 2px;
  display: block;
  margin-bottom: 5px;
  font-weight: bold;
}
.message.user {
  align-self: flex-end;
  background: rgba(0, 100, 0, 0.18);
  border: none;
  border-right: 3px solid rgba(60, 150, 60, 0.75);
  border-radius: 6px 0 0 6px;
  color: #8edd8e;
  box-shadow: 0 2px 10px rgba(0,0,0,0.42), 2px 0 12px rgba(30,110,30,0.20);
}
.message.user::before {
  content: '[ YOU ]';
  display: block;
  color: #3a9a3a;
  font-size: 0.7em;
  font-weight: bold;
  letter-spacing: 2.5px;
  margin-bottom: 4px;
  opacity: 0.8;
}
.message.kitt {
  align-self: flex-start;
  background: rgba(160, 10, 0, 0.22);
  border: none;
  border-left: 3px solid rgba(220, 50, 0, 0.80);
  border-radius: 0 6px 6px 0;
  color: #ffbcbc;
  overflow: hidden;
  box-shadow: 0 2px 10px rgba(0,0,0,0.42), -2px 0 12px rgba(160,20,0,0.20);
}
.message.kitt::before {
  content: '[ KITT ]';
  display: block;
  color: #dd3311;
  font-size: 0.7em;
  font-weight: bold;
  letter-spacing: 2.5px;
  margin-bottom: 4px;
  text-shadow: 0 0 8px #ff000088;
  opacity: 0.9;
}
@keyframes kittScan {
  from { transform: translateX(-100%); opacity: 1; }
  to   { transform: translateX(450%);  opacity: 0; }
}
@-webkit-keyframes kittScan {
  from { -webkit-transform: translateX(-100%); opacity: 1; }
  to   { -webkit-transform: translateX(450%);  opacity: 0; }
}
.message.kitt::after {
  content: '';
  position: absolute;
  top: 0; left: 0; bottom: 0;
  width: 28%;
  background: linear-gradient(90deg, transparent 0%, rgba(220,40,0,0.22) 50%, transparent 100%);
  animation: kittScan 0.65s ease-out 0.28s both;
  -webkit-animation: kittScan 0.65s ease-out 0.28s both;
  pointer-events: none;
}
.message .timing {
  font-size: 0.6em;
  color: #552222;
  opacity: 0.5;
  font-style: italic;
  margin-top: 6px;
  padding-top: 4px;
  border-top: 1px solid #1e1010;
  letter-spacing: 1px;
}
.typing {
  display: inline-block;
  letter-spacing: 2px;
  color: rgba(255,140,140,0.75);
  text-shadow: 0 0 8px rgba(220,40,0,0.6);
  animation: typing-pulse 1.3s ease-in-out infinite;
  -webkit-animation: typing-pulse 1.3s ease-in-out infinite;
}
@keyframes typing-pulse {
  0%, 100% { opacity: 0.25; letter-spacing: 1px; }
  50% { opacity: 1; letter-spacing: 5px; text-shadow: 0 0 14px rgba(220,40,0,0.95); }
}
@-webkit-keyframes typing-pulse {
  0%, 100% { opacity: 0.25; letter-spacing: 1px; }
  50% { opacity: 1; letter-spacing: 5px; }
}
.message.proactive {
  background: rgba(110, 55, 0, 0.14);
  border: none;
  border-left: 3px solid rgba(255, 140, 0, 0.55);
  border-radius: 0 6px 6px 0;
  color: #ffbb55;
  font-style: italic;
}
.message.proactive::before {
  content: '[ ALERTE ]';
  display: block;
  color: #ff8800;
  font-size: 0.7em;
  font-weight: bold;
  letter-spacing: 2.5px;
  margin-bottom: 4px;
  opacity: 0.8;
}

/* Input area */
.input-area {
  padding: 10px 14px max(12px, env(safe-area-inset-bottom));
  border-top: 1px solid #1e0000;
  background: linear-gradient(0deg, #0a0000 0%, transparent 100%);
  display: flex;
  gap: 8px;
  align-items: center;
  position: relative;
  flex-shrink: 0;
}
.input-area::before {
  content: '';
  position: absolute;
  top: 0; left: 10%; right: 10%;
  height: 1px;
  background: linear-gradient(90deg, transparent, #440000, #660000, #440000, transparent);
}
.input-area input {
  flex: 1;
  background: #0d0000;
  border: 1px solid #2a0000;
  border-bottom: 2px solid #440000;
  color: #ddaaaa;
  padding: 10px 14px;
  border-radius: 3px;
  font-family: inherit;
  font-size: 0.9em;
  outline: none;
  letter-spacing: 0.5px;
  transition: all 0.2s;
}
.input-area input::placeholder { color: #774444; }
.input-area input:focus {
  border-color: #880000;
  border-bottom-color: #ff2200;
  color: #ffbbbb;
  animation: kitt-input-focus 2s ease-in-out infinite;
}
@keyframes kitt-input-focus {
  0%, 100% { box-shadow: 0 2px 12px #ff000022, inset 0 0 10px #ff000008; border-bottom-color: #ff2200; }
  50%       { box-shadow: 0 2px 28px #ff000066, inset 0 0 20px #ff000020; border-bottom-color: #ff5500; }
}
@-webkit-keyframes kitt-input-focus {
  0%, 100% { box-shadow: 0 2px 12px #ff000022, inset 0 0 10px #ff000008; border-bottom-color: #ff2200; }
  50%       { box-shadow: 0 2px 28px #ff000066, inset 0 0 20px #ff000020; border-bottom-color: #ff5500; }
}
.input-area button#send {
  background: linear-gradient(180deg, #cc0000, #880000);
  color: #fff;
  border: 1px solid #ff2200;
  border-bottom: 2px solid #550000;
  padding: 10px 18px;
  border-radius: 3px;
  cursor: pointer;
  font-family: inherit;
  font-weight: bold;
  font-size: 0.8em;
  letter-spacing: 2px;
  transition: all 0.2s;
  text-shadow: 0 0 8px #ff000088;
}
.input-area button#send:hover {
  background: linear-gradient(180deg, #ff1100, #aa0000);
  box-shadow: 0 0 12px #ff000044;
}
.input-area button#send:disabled {
  background: linear-gradient(180deg, #1a1a1a, #111);
  border-color: #333;
  border-bottom-color: #222;
  color: #444;
  cursor: not-allowed;
  text-shadow: none;
  box-shadow: none;
}
.input-area button#send.sending {
  animation: kitt-send-pulse 1.1s ease-in-out infinite;
  cursor: wait;
  color: #cc4422;
  text-shadow: 0 0 8px #ff220066;
}
@keyframes kitt-send-pulse {
  0%, 100% { background: linear-gradient(180deg, #1a0000, #0d0000); border-color: #440000; border-bottom-color: #220000; box-shadow: none; }
  50%       { background: linear-gradient(180deg, #880000, #550000); border-color: #cc0000; border-bottom-color: #440000; box-shadow: 0 0 14px #ff000055, inset 0 0 8px #ff000011; }
}
.input-area button#send.ready:not(.sending):not(:disabled) {
  animation: kitt-send-ready 1.6s ease-in-out infinite;
  border-bottom-color: #cc2200;
}
@keyframes kitt-send-ready {
  0%, 100% { box-shadow: 0 0 6px #ff000044; }
  50%       { box-shadow: 0 0 18px #ff000099, 0 0 32px #ff220033; }
}

/* Mic buttons */
.mic-btn, .auto-btn {
  background: radial-gradient(circle at 35% 35%, #2a1010, #110000);
  color: #ff5555;
  border: 1px solid #660000;
  box-shadow: 0 0 6px #ff000022, inset 0 1px 0 #3a1010;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 0.58em;
  font-weight: bold;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.25s;
  flex-shrink: 0;
  padding: 0;
  letter-spacing: 0.5px;
}
.mic-btn:hover, .auto-btn:hover {
  background: radial-gradient(circle at 35% 35%, #3d1515, #1a0000);
  border-color: #990000;
  box-shadow: 0 0 12px #ff000033;
}
.mic-btn.recording, .auto-btn.active {
  background: #aa0000;
  color: white;
  border-color: #ff4444;
  animation: mic-pulse 1s ease-in-out infinite;
  box-shadow: 0 0 15px #ff000066;
}
.auto-btn.active.waiting {
  background: #004400;
  border-color: #00aa00;
  color: #44ff44;
  animation: auto-pulse 2s ease-in-out infinite;
}
.auto-btn.active.hearing {
  background: #aa0000;
  border-color: #ff4444;
  color: white;
  animation: mic-pulse 0.5s ease-in-out infinite;
}
@keyframes mic-pulse {
  0%, 100% { box-shadow: 0 0 10px #ff000044; }
  50% { box-shadow: 0 0 25px #ff000088; }
}
@keyframes auto-pulse {
  0%, 100% { box-shadow: 0 0 5px #00ff0022; }
  50% { box-shadow: 0 0 15px #00ff0044; }
}
.mic-btn.transcribing, .auto-btn.transcribing {
  background: #553300;
  color: #ffaa44;
  border-color: #ff8800;
  animation: none;
}

/* Camera button */
.cam-btn {
  background: radial-gradient(circle at 35% 35%, #2a1010, #110000);
  color: #ff5555;
  border: 1px solid #660000;
  box-shadow: 0 0 6px #ff000022, inset 0 1px 0 #3a1010;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  cursor: pointer;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s;
  flex-shrink: 0;
  padding: 0;
}
.cam-btn:hover { background: radial-gradient(circle at 35% 35%, #3d1515, #1a0000); border-color: #990000; box-shadow: 0 0 12px #ff000033; }
.cam-btn:disabled { background: #0d0d0d; cursor: not-allowed; border-color: #222; color: #333; box-shadow: none; }
.cam-btn.capturing {
  background: #004466;
  color: #44aaff;
  border-color: #0088cc;
  animation: cam-pulse 1s ease-in-out infinite;
}
@keyframes cam-pulse {
  0%, 100% { box-shadow: 0 0 10px #0088cc44; }
  50% { box-shadow: 0 0 25px #0088cc88; }
}

/* Wake button */
.wake-btn {
  background: radial-gradient(circle at 35% 35%, #1a0a2a, #0d0011);
  color: #bb77ff;
  border: 1px solid #440077;
  box-shadow: 0 0 6px #7700aa22, inset 0 1px 0 #2a0a3a;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 0.58em;
  font-weight: bold;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.25s;
  flex-shrink: 0;
  padding: 0;
  letter-spacing: 0.5px;
}
.wake-btn:hover { background: radial-gradient(circle at 35% 35%, #2a1040, #150022); border-color: #7700aa; box-shadow: 0 0 12px #7700aa33; }
.wake-btn.active.waiting {
  background: #220044;
  border-color: #7700aa;
  color: #bb88ff;
  animation: wake-pulse 2.5s ease-in-out infinite;
}
.wake-btn.active.hearing {
  background: #7700aa;
  border-color: #bb44ff;
  color: white;
  animation: mic-pulse 0.5s ease-in-out infinite;
}
.wake-btn.transcribing {
  background: #553300;
  color: #ffaa44;
  border-color: #ff8800;
  animation: none;
}
.wake-btn.active.wake-triggered {
  background: #9900cc;
  border-color: #cc44ff;
  color: white;
  animation: wake-triggered-pulse 0.6s ease-in-out infinite;
}
@keyframes wake-pulse {
  0%, 100% { box-shadow: 0 0 5px #7700aa22; }
  50% { box-shadow: 0 0 15px #7700aa55; }
}
@keyframes wake-triggered-pulse {
  0%, 100% { box-shadow: 0 0 10px #9900cc66; }
  50% { box-shadow: 0 0 30px #cc44ffaa; }
}

/* Voicebox KITT — barres réactives audio */
.voicebox-container {
  display: none;
}
#voicebox {
  display: block;
  border-radius: 3px;
  background: rgba(10, 0, 0, 0.6);
  border: 1px solid #220000;
  max-width: calc(100% - 40px);
}

/* Scanner listening/wake/auto modes — vitesse et couleur gérées par JS rAF */

/* Audio activation button */
.audio-btn {
  background: radial-gradient(circle at 35% 35%, #2a1010, #110000);
  color: #ff5555;
  border: 1px solid #660000;
  box-shadow: 0 0 6px #ff000022, inset 0 1px 0 #3a1010;
  width: 44px;
  height: 44px;
  border-radius: 50%;
  cursor: pointer;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.25s;
  flex-shrink: 0;
  padding: 0;
  position: relative;
}
.audio-btn:hover { background: radial-gradient(circle at 35% 35%, #3d1515, #1a0000); border-color: #990000; box-shadow: 0 0 12px #ff000033; }
.audio-btn .slash { display: block; }
.audio-btn.active { background: radial-gradient(circle at 35% 35%, #0d2a0d, #001100); color: #44ff44; border-color: #006600; box-shadow: 0 0 10px #00ff0022; }
.audio-btn.active .slash { display: none; }

/* ── Modal identification MU-TH-UR 6000 — style Alien 1979 ── */
.name-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,4,0,0.96);
  z-index: 200;
  justify-content: center;
  align-items: center;
  padding: 20px;
  /* Ligne de scan verte qui descend en boucle */
  background-image: repeating-linear-gradient(
    0deg, transparent, transparent 3px, rgba(0,255,60,0.015) 4px
  );
}
.name-overlay.visible { display: flex; }
.name-box {
  max-width: 420px;
  width: 100%;
  border: 1px solid rgba(0,200,60,0.35);
  border-top: 2px solid rgba(0,255,80,0.6);
  padding: 32px 28px 28px;
  background: rgba(0,8,0,0.95);
  text-align: center;
  position: relative;
  box-shadow: 0 0 40px rgba(0,255,60,0.08), inset 0 0 30px rgba(0,0,0,0.5);
}
.name-box::before {
  content: '';
  position: absolute;
  top: 0; left: 10%; right: 10%;
  height: 2px;
  background: linear-gradient(90deg, transparent, #00ff44, transparent);
  box-shadow: 0 0 12px #00ff4488;
}
.name-box .mb-system {
  font-size: 0.52em;
  color: #005522;
  letter-spacing: 4px;
  margin-bottom: 4px;
  text-transform: uppercase;
}
.name-box h2 {
  font-size: 1.3em;
  color: #00ee55;
  letter-spacing: 5px;
  margin-bottom: 4px;
  text-shadow: 0 0 20px #00ff4466;
  animation: mother-flicker 9s ease-in-out infinite;
}
.name-box .mb-sub {
  font-size: 0.55em;
  color: #006633;
  letter-spacing: 2px;
  margin-bottom: 22px;
  border-bottom: 1px solid rgba(0,180,60,0.2);
  padding-bottom: 14px;
}
.name-box input {
  width: 100%;
  background: rgba(0,12,0,0.9);
  border: 1px solid rgba(0,180,60,0.4);
  border-bottom: 2px solid rgba(0,255,80,0.5);
  color: #00ff77;
  padding: 12px 16px;
  font-family: inherit;
  font-size: 16px;
  text-align: center;
  outline: none;
  letter-spacing: 3px;
  text-transform: uppercase;
  caret-color: #00ff77;
}
.name-box input::placeholder { color: #004422; letter-spacing: 2px; text-transform: none; }
.name-box input:focus { border-color: rgba(0,255,80,0.7); box-shadow: 0 0 12px rgba(0,255,60,0.15); }

/* Sélecteur de langue dans la modal */
.lang-selector {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin: 18px 0 22px;
}
.lang-opt {
  background: rgba(0,10,0,0.8);
  border: 1px solid rgba(0,150,50,0.35);
  color: #006633;
  font-family: inherit;
  font-size: 0.65em;
  font-weight: bold;
  letter-spacing: 2px;
  padding: 6px 14px;
  cursor: pointer;
  transition: all 0.2s;
  border-radius: 2px;
}
.lang-opt:hover { border-color: rgba(0,255,80,0.5); color: #00aa44; }
.lang-opt.selected {
  background: rgba(0,40,15,0.9);
  border-color: rgba(0,255,80,0.7);
  color: #00ff77;
  box-shadow: 0 0 8px rgba(0,255,60,0.2);
}
.name-box .mb-btn {
  background: rgba(0,40,15,0.9);
  color: #00ff77;
  border: 1px solid rgba(0,255,80,0.5);
  border-bottom: 2px solid rgba(0,200,60,0.4);
  padding: 12px 36px;
  font-family: inherit;
  font-weight: bold;
  font-size: 0.8em;
  letter-spacing: 3px;
  cursor: pointer;
  transition: all 0.2s;
  text-shadow: 0 0 8px rgba(0,255,80,0.5);
}
.name-box .mb-btn:hover {
  background: rgba(0,60,20,0.9);
  box-shadow: 0 0 16px rgba(0,255,60,0.2);
}
.name-box .mb-prompt {
  font-size: 0.6em;
  color: #004422;
  letter-spacing: 1.5px;
  margin-bottom: 14px;
}
.mb-secret-toggle {
  margin-top: 18px; font-size: 0.5em; color: #1a3a1a;
  letter-spacing: 2px; cursor: pointer; transition: color 0.3s;
  text-align: center; user-select: none;
}
.mb-secret-toggle:hover { color: #447744; }
.mb-secret-box {
  display: none; margin-top: 10px; padding-top: 12px;
  border-top: 1px solid rgba(0,200,60,0.15);
}
.mb-secret-box input {
  background: rgba(0,15,0,0.8);
  border: none; border-bottom: 2px solid rgba(0,200,60,0.4);
  color: #88ff88; font-family: inherit; font-size: 1em;
  letter-spacing: 6px; padding: 8px 12px; text-align: center;
  width: 100%; outline: none; margin-bottom: 8px; caret-color: #00ff66;
  box-sizing: border-box;
}
.mb-secret-btn {
  background: transparent; border: 1px solid rgba(0,200,60,0.25);
  color: #336633; font-family: inherit; font-size: 0.5em;
  letter-spacing: 2px; padding: 5px 16px; cursor: pointer;
  width: 100%; transition: all 0.3s; border-radius: 2px;
}
.mb-secret-btn:hover { color: #66ff66; border-color: rgba(0,200,60,0.6); }
.mb-secret-msg {
  font-size: 0.5em; letter-spacing: 2px; text-align: center;
  margin-top: 8px; min-height: 1.2em;
}
@keyframes shake-secret {
  0%,100% { transform: translateX(0); }
  25%,75% { transform: translateX(-7px); }
  50% { transform: translateX(7px); }
}
.mb-shake { animation: shake-secret 0.35s ease; }

/* Status */
.status-bar {
  display: none;
}
.status-bar .online { color: #448844; text-shadow: 0 0 6px #00440022; }
.status-bar .offline { color: #884444; }
.status-bar .thinking { color: #886633; animation: blink-status 0.8s step-end infinite; }
@keyframes blink-status { 0%,100%{opacity:1;} 50%{opacity:0.3;} }

/* Orbe énergétique 3D — arrière-plan réactif */
#orb {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  z-index: 2 !important;
  pointer-events: none;
}

/* ── Fond Jarvis holographique ── */
#jarvis-bg {
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;   /* inset: 0 invisible sur iOS Safari */
  display: flex; align-items: center; justify-content: center;
  z-index: 0 !important;
  pointer-events: none; overflow: hidden;
  -webkit-transform: translate3d(0, 0, 0); /* force GPU rendering iOS */
  transform: translate3d(0, 0, 0);
}
#jarvis-svg {
  width: min(90vw, 90vh); height: min(90vw, 90vh);
  max-width: 520px; max-height: 520px;
  opacity: 1;          /* Les stroke-opacity internes gèrent la transparence */
  will-change: opacity;
  -webkit-animation: jarvis-breathe 9s ease-in-out infinite;
  animation: jarvis-breathe 9s ease-in-out infinite;
}
@-webkit-keyframes jarvis-breathe {
  0%,100% { opacity: 0.80; }
  50%      { opacity: 1.0; }
}
@keyframes jarvis-breathe {
  0%,100% { opacity: 0.80; }
  50%      { opacity: 1.0; }
}

/* ── Apparition messages ── */
.message {
  animation: msg-appear 0.42s cubic-bezier(0.34,1.56,0.64,1) both;
  -webkit-animation: msg-appear 0.42s cubic-bezier(0.34,1.56,0.64,1) both;
}
@keyframes msg-appear {
  from { opacity: 0; transform: translateY(10px) scale(0.96); }
  to   { opacity: 1; transform: translateY(0) scale(1); }
}
@-webkit-keyframes msg-appear {
  from { opacity: 0; -webkit-transform: translateY(10px) scale(0.96); }
  to   { opacity: 1; -webkit-transform: translateY(0) scale(1); }
}

/* ── Feedback tactile boutons ── */
.mic-btn:active, .auto-btn:active, .wake-btn:active,
.cam-btn:active, .audio-btn:active {
  transform: scale(0.92);
  transition: transform 0.08s ease;
}
#send:active { transform: scale(0.97); transition: transform 0.08s ease; }

/* ── Focus input — glow container + scanner sweep ── */
.input-area:focus-within {
  background: linear-gradient(0deg, #0d0000 0%, transparent 100%);
  box-shadow: 0 -4px 20px #ff000018;
}
.input-area::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, #ff2200 50%, transparent) no-repeat;
  background-size: 40% 100%;
  background-position: -40% 0;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.4s;
}
.input-area:focus-within::after {
  opacity: 1;
  animation: kitt-scan-sweep 2.2s linear infinite;
}
@keyframes kitt-scan-sweep {
  0%   { background-position: -40% 0; }
  100% { background-position: 140% 0; }
}

/* ── Sphère holographique 3D CSS ── */
#sphere-wrap {
  position: fixed;
  top: 50%; left: 50%;
  width: 0; height: 0;
  z-index: 0 !important;
  pointer-events: none;
  -webkit-perspective: 700px;
  perspective: 700px;
  transition: transform 0.07s ease-out;
}
#jarvis-svg {
  transition: filter 0.07s ease-out;
}
#sphere-3d {
  position: absolute;
  width: 220px; height: 220px;
  top: -110px; left: -110px;
  -webkit-transform-style: preserve-3d;
  transform-style: preserve-3d;
  -webkit-animation: sphere-spin 22s linear infinite;
  animation: sphere-spin 22s linear infinite;
}
@-webkit-keyframes sphere-spin {
  from { -webkit-transform: rotateX(22deg) rotateY(0deg); }
  to   { -webkit-transform: rotateX(22deg) rotateY(360deg); }
}
@keyframes sphere-spin {
  from { transform: rotateX(22deg) rotateY(0deg); }
  to   { transform: rotateX(22deg) rotateY(360deg); }
}
.s-mer {
  position: absolute;
  inset: 0;
  border-radius: 50%;
  border: 1px solid rgba(255,34,0,0.60);
  box-shadow: 0 0 10px rgba(255,0,0,0.20);
  -webkit-transform: rotateY(var(--r));
  transform: rotateY(var(--r));
}
.s-par {
  position: absolute;
  border-radius: 50%;
  border: 1px solid rgba(255,34,0,0.50);
  -webkit-transform: translateY(var(--ty)) rotateX(90deg);
  transform: translateY(var(--ty)) rotateX(90deg);
}
.s-core {
  position: absolute;
  width: 18px; height: 18px;
  top: 50%; left: 50%;
  margin: -9px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 35%, #ff5500, #cc0000);
  box-shadow: 0 0 22px #ff2200, 0 0 55px #ff000088;
  -webkit-animation: s-core-pulse 2.2s ease-in-out infinite;
  animation: s-core-pulse 2.2s ease-in-out infinite;
}
@-webkit-keyframes s-core-pulse {
  0%,100% { box-shadow: 0 0 18px #ff2200, 0 0 40px #ff000055; -webkit-transform: scale(1); }
  50%      { box-shadow: 0 0 38px #ff4400, 0 0 80px #ff0000bb; -webkit-transform: scale(1.6); }
}
@keyframes s-core-pulse {
  0%,100% { box-shadow: 0 0 18px #ff2200, 0 0 40px #ff000055; transform: scale(1); }
  50%      { box-shadow: 0 0 38px #ff4400, 0 0 80px #ff0000bb; transform: scale(1.6); }
}
@media (max-width: 480px) {
  #sphere-3d { width: 160px; height: 160px; top: -80px; left: -80px; }
}

/* ── Scan beam Knight Rider — ligne rouge descendante ── */
.scan-beam {
  position: fixed;
  top: -3px; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent 0%, rgba(255,0,0,0) 10%, rgba(255,40,0,0.55) 40%, rgba(255,80,0,0.7) 50%, rgba(255,40,0,0.55) 60%, rgba(255,0,0,0) 90%, transparent 100%);
  box-shadow: 0 0 10px rgba(255,30,0,0.45), 0 0 24px rgba(255,0,0,0.18);
  pointer-events: none;
  z-index: 50;
  animation: scan-beam-fall 14s linear infinite;
}
@keyframes scan-beam-fall {
  0%   { top: -3px; opacity: 0; }
  3%   { opacity: 1; }
  97%  { opacity: 0.85; }
  100% { top: 100vh; opacity: 0; }
}

/* ── MU-TH-UR 6000 — panneau diagnostic vert phosphore ── */
/* ═══════════════════════════════════════════════
   MU-TH-UR 6000 — PANNEAU DROIT REDESIGN COMPLET
   ═══════════════════════════════════════════════ */
.mother-panel {
  position: fixed;
  top: 50%; right: 0;
  transform: translateY(-50%);
  width: 200px;
  background: linear-gradient(160deg, rgba(0,12,4,0.97) 0%, rgba(0,6,2,0.99) 100%);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border-left: 1px solid rgba(0,255,100,0.22);
  border-top: 1px solid rgba(0,255,100,0.12);
  border-bottom: 1px solid rgba(0,255,100,0.12);
  border-radius: 10px 0 0 10px;
  font-family: 'Courier New', monospace;
  font-size: 0.5em;
  color: #00bb44;
  letter-spacing: 1px;
  line-height: 1.8;
  pointer-events: none;
  z-index: 3;
  overflow: hidden;
  max-height: 75vh;
  box-shadow:
    -6px 0 30px rgba(0,255,80,0.08),
    -2px 0 8px rgba(0,255,80,0.04),
    inset 1px 0 0 rgba(0,255,100,0.05),
    inset 0 0 40px rgba(0,20,8,0.6);
}
/* Scan line animé dans le panneau */
.mother-panel::before {
  content: '';
  position: absolute; left: 0; right: 0; height: 1px;
  background: linear-gradient(90deg, transparent, rgba(0,255,80,0.25), transparent);
  animation: mp-scan 5s linear infinite;
  pointer-events: none; z-index: 1;
}
@keyframes mp-scan { 0% { top: -2px; } 100% { top: 101%; } }
/* Effet CRT lignes horizontales */
.mother-panel::after {
  content: '';
  position: absolute; top: 0; left: 0; right: 0; bottom: 0;
  background: repeating-linear-gradient(
    0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 3px
  );
  pointer-events: none; z-index: 0;
}
/* Bandeau titre */
.mother-panel .mp-header-band {
  background: linear-gradient(90deg, rgba(0,40,15,0.9), rgba(0,20,8,0.6));
  border-bottom: 1px solid rgba(0,255,100,0.18);
  padding: 8px 12px 6px;
  position: relative; z-index: 2;
}
.mother-panel .mp-corp {
  font-size: 0.75em; letter-spacing: 3px;
  color: rgba(0,180,60,0.5); margin-bottom: 1px;
}
.mother-panel .mp-title {
  color: #00ff77;
  letter-spacing: 4px;
  font-size: 1.15em;
  font-weight: bold;
  text-shadow: 0 0 12px rgba(0,255,100,0.5), 0 0 30px rgba(0,255,100,0.15);
}
/* Corps données */
.mother-panel .mp-body {
  padding: 8px 12px 10px;
  position: relative; z-index: 2;
}
.mother-panel .mp-row {
  display: flex; justify-content: space-between;
  gap: 4px; margin-bottom: 2px; align-items: baseline;
}
.mother-panel .mp-label {
  color: #006633; flex-shrink: 0;
  letter-spacing: 1.5px; font-size: 0.9em;
}
.mother-panel .mp-value {
  color: #00ff77; text-align: right;
  word-break: break-all; font-size: 0.95em;
  text-shadow: 0 0 6px rgba(0,255,100,0.3);
}
.mother-panel .mp-sep {
  border: none;
  border-top: 1px solid rgba(0,200,80,0.12);
  margin: 6px 0;
  position: relative;
}
.mother-panel .mp-sep::after {
  content: ''; position: absolute;
  left: 20%; right: 20%; top: 0; height: 1px;
  background: rgba(0,255,80,0.1);
  box-shadow: 0 0 4px rgba(0,255,80,0.15);
}
/* Section mémoire */
.mother-panel .mp-mem-title {
  color: #005522; font-size: 0.85em;
  letter-spacing: 3px; margin-bottom: 5px;
  padding-top: 2px;
}
.mother-panel .mp-mem-item {
  background: rgba(0,30,10,0.4);
  border: 1px solid rgba(0,150,50,0.1);
  border-left: 2px solid rgba(0,255,80,0.2);
  border-radius: 0 3px 3px 0;
  color: #00cc55; font-size: 0.9em; line-height: 1.5;
  padding: 3px 6px; margin-bottom: 4px;
  word-break: break-word;
}
.mother-panel .mp-mem-user {
  color: #004422; font-size: 0.8em;
  letter-spacing: 1.5px; margin-top: 1px;
}
@media (max-width: 600px) { .mother-panel { display: none; } }

/* ── Badge stats mobile (sous scanner) ── */
.mobile-stats { display: none; text-align: center; font-size: 0.5em; color: #444; letter-spacing: 1.5px; padding: 2px 10px; }
@media (max-width: 600px) { .mobile-stats { display: block; } }

/* ── Bouton Reset (dans header, gauche) ── */
/* ── Conteneur boutons header centré ── */
.header-btns {
  position: absolute;
  left: 50%; top: calc(50% + 52px);
  transform: translate(-50%, -50%);
  display: flex;
  gap: 10px;
  align-items: center;
  z-index: 10;
}
.reset-btn {
  position: relative; transform: none;
  background: transparent; border: 1px solid #661122; color: #aa3333;
  font-size: 0.48em; font-family: inherit; font-weight: bold;
  letter-spacing: 1.5px; padding: 3px 7px; cursor: pointer; border-radius: 2px;
  transition: all 0.3s; -webkit-tap-highlight-color: transparent;
}
.reset-btn:hover { color: #ff3333; border-color: #ff3333; box-shadow: 0 0 8px #ff000033; }
.reset-btn:active { transform: translateY(-50%) scale(0.95); }

/* ── Bouton sons d'ambiance (dans header) ── */
.ambient-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #115533;
  color: #226644;
  font-size: 0.48em;
  font-family: inherit;
  font-weight: bold;
  letter-spacing: 1.5px;
  padding: 3px 7px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.3s;
  -webkit-tap-highlight-color: transparent;
}
.ambient-btn:hover { color: #00aa44; border-color: #00aa44; box-shadow: 0 0 8px #00ff2222; }
.ambient-btn.active {
  color: #00ff77;
  border-color: #00cc55;
  box-shadow: 0 0 10px #00ff4433;
  animation: ambient-pulse 3.5s ease-in-out infinite;
}
@keyframes ambient-pulse {
  0%,100% { box-shadow: 0 0 6px #00ff2222; text-shadow: none; }
  50% { box-shadow: 0 0 16px #00ff4455; text-shadow: 0 0 8px #00ff7755; }
}

/* ── Bouton Vigilance (dans header, à gauche de AMB) ── */
.vig-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #882233;
  color: #aa2233;
  font-size: 0.48em;
  font-family: inherit;
  font-weight: bold;
  letter-spacing: 1.5px;
  padding: 3px 7px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.3s;
  -webkit-tap-highlight-color: transparent;
}
.vig-btn:hover { color: #cc2233; border-color: #cc2233; box-shadow: 0 0 8px #ff002233; }
.vig-btn.active {
  color: #ff4455;
  border-color: #ff3344;
  box-shadow: 0 0 10px #ff002244;
  animation: vig-pulse 1.8s ease-in-out infinite;
}
@keyframes vig-pulse {
  0%,100% { box-shadow: 0 0 6px #ff002233; }
  50% { box-shadow: 0 0 18px #ff004466; text-shadow: 0 0 8px #ff335566; }
}

/* ── Bouton Visiteurs (dans header, à gauche de NIGHT) ── */
.vis-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #665511;
  color: #886622;
  font-size: 0.48em;
  font-family: inherit;
  font-weight: bold;
  letter-spacing: 1.5px;
  padding: 3px 7px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.3s;
  -webkit-tap-highlight-color: transparent;
}
.vis-btn:hover { color: #ffaa00; border-color: #cc8800; box-shadow: 0 0 8px #ffaa0033; }
.vis-btn.active { color: #ffcc44; border-color: #ffaa00; box-shadow: 0 0 10px #ffaa0044; }

/* ── Bouton Rapport Mode Auto (dans header, à gauche de VIS) ── */
.rpt-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #445511;
  color: #667722;
  font-size: 0.48em;
  font-family: inherit;
  font-weight: bold;
  letter-spacing: 1.5px;
  padding: 3px 7px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.3s;
  -webkit-tap-highlight-color: transparent;
}
.rpt-btn:hover { color: #aacc00; border-color: #88aa00; box-shadow: 0 0 8px #aacc0033; }
.rpt-btn.active { color: #ccee22; border-color: #aacc00; box-shadow: 0 0 10px #aacc0044; }

.enhance-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #5522aa;
  color: #7733bb;
  font-size: 0.48em; font-family: inherit; font-weight: bold;
  letter-spacing: 1.5px; padding: 3px 7px;
  cursor: pointer; border-radius: 2px;
  transition: all 0.3s; -webkit-tap-highlight-color: transparent;
}
.enhance-btn:hover { color: #8844cc; border-color: #7733bb; box-shadow: 0 0 8px #aa44ff33; }
.enhance-btn.active {
  color: #aa66ff; border-color: #8833dd;
  box-shadow: 0 0 10px #aa44ff44;
  animation: enhance-pulse 3s ease-in-out infinite;
}
@keyframes enhance-pulse {
  0%,100% { box-shadow: 0 0 6px #aa44ff22; text-shadow: none; }
  50% { box-shadow: 0 0 18px #aa44ff55; text-shadow: 0 0 8px #aa66ff66; }
}

/* ── Bouton Download HTML ── */
.dl-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #114455;
  color: #226677;
  font-size: 0.48em; font-family: inherit; font-weight: bold;
  letter-spacing: 1.5px; padding: 3px 7px;
  cursor: pointer; border-radius: 2px;
  transition: all 0.3s; -webkit-tap-highlight-color: transparent;
}
.dl-btn:hover { color: #44bbdd; border-color: #2299bb; box-shadow: 0 0 8px #44bbdd33; }
.git-btn {
  position: relative; transform: none;
  background: transparent; border: 1px solid #115522; color: #227744;
  font-size: 0.48em; font-family: inherit; font-weight: bold;
  letter-spacing: 1.5px; padding: 3px 7px;
  cursor: pointer; border-radius: 2px;
  transition: all 0.3s; -webkit-tap-highlight-color: transparent;
}
.git-btn:hover { color: #44ff88; border-color: #22cc55; box-shadow: 0 0 8px #44ff8833; }
.git-btn.pushing { color: #ffaa00; border-color: #cc8800; }
.run-btn {
  position: relative; transform: none;
  background: transparent; border: 1px solid #442200; color: #884400;
  font-size: 0.48em; font-family: inherit; font-weight: bold;
  letter-spacing: 1.5px; padding: 3px 7px;
  cursor: pointer; border-radius: 2px;
  transition: all 0.3s; -webkit-tap-highlight-color: transparent;
}
.run-btn:hover { color: #ffaa44; border-color: #cc6600; box-shadow: 0 0 8px #ffaa4433; }
.run-btn.running { color: #ff8800; border-color: #ff6600; animation: enhance-pulse 1s ease-in-out infinite; }

/* === MODE AMELIORATION AUTO === */
body.enhanced .message.kitt {
  background: rgba(140,0,0,0.12);
  border-left-color: rgba(255,50,0,0.65);
  box-shadow: 0 2px 10px rgba(0,0,0,0.42), -2px 0 14px rgba(255,0,0,0.12);
}
body.enhanced .message.user {
  background: rgba(0,100,0,0.10);
  border-right-color: rgba(50,180,50,0.55);
  box-shadow: 0 2px 10px rgba(0,0,0,0.42), 2px 0 12px rgba(0,255,0,0.10);
}
body.enhanced .input-area input:focus {
  box-shadow: 0 2px 20px #ff000033, inset 0 0 16px #ff000010, 0 0 35px #ff000011;
}
body.enhanced #send:not(:disabled):not(.sending) {
  box-shadow: 0 0 15px #ff000033, 0 2px 8px #cc000044;
}
body.enhanced .chat-area {
  box-shadow:
    inset 0 0 60px rgba(160,0,0,0.07),
    inset 0 16px 32px rgba(0,0,0,0.32),
    inset 0 -16px 32px rgba(0,0,0,0.32);
}
body.enhanced .header h1 {
  text-shadow: 0 0 30px #ff0000, 0 0 65px #ff000055, 0 0 100px #ff000022;
}
body.enhanced .message {
  transition: background 0.4s, border-color 0.4s, box-shadow 0.4s;
}

/* ── Overlay Rapport Mode Auto ── */
.rpt-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.88);
  z-index: 500;
  align-items: center;
  justify-content: center;
  padding: 16px;
}
.rpt-overlay.visible { display: flex; }
.rpt-panel {
  background: #060808;
  border: 1px solid #aacc00;
  border-radius: 4px;
  padding: 0;
  width: 100%;
  max-width: 640px;
  max-height: 90vh;
  overflow-y: auto;
  font-family: 'Space Mono', 'Courier New', monospace;
  color: #aacc00;
  box-shadow: 0 0 30px #aacc0022;
}
.rpt-header {
  background: #0a0f00;
  border-bottom: 1px solid #aacc00;
  padding: 10px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky; top: 0;
}
.rpt-header-title { font-size: 0.75em; letter-spacing: 2px; color: #ccee44; }
.rpt-close {
  background: none; border: none; color: #aacc00;
  font-size: 1.2em; cursor: pointer; padding: 0 4px; line-height: 1;
}
.rpt-body { padding: 14px 16px; font-size: 0.68em; }
.rpt-section { margin-bottom: 16px; }
.rpt-section-title {
  color: #ccee44; font-size: 0.85em; letter-spacing: 1.5px;
  border-bottom: 1px solid #334400; padding-bottom: 4px; margin-bottom: 8px;
}
.rpt-row {
  display: flex; gap: 8px; margin-bottom: 4px; align-items: baseline;
}
.rpt-tag {
  background: #1a2200; border: 1px solid #334400;
  color: #88aa00; font-size: 0.85em; padding: 1px 6px; border-radius: 2px;
  white-space: nowrap; min-width: 36px; text-align: center;
}
.rpt-tag.ok { background: #0a1f00; border-color: #446600; color: #aadd00; }
.rpt-tag.fail { background: #1f0a00; border-color: #662200; color: #dd6600; }
.rpt-text { color: #99bb00; line-height: 1.5; }
.rpt-text em { color: #ccee44; font-style: normal; }
.rpt-meta { color: #445500; font-size: 0.85em; }
.rpt-log-line { color: #667700; margin: 2px 0; }
.rpt-log-line.ok { color: #88bb00; }
.rpt-log-line.fail { color: #cc5500; }
.rpt-loading { text-align: center; padding: 30px; color: #334400; }
.rpt-refresh {
  background: #0a1500; border: 1px solid #334400; color: #88aa00;
  font-family: inherit; font-size: 0.7em; letter-spacing: 1px;
  padding: 4px 10px; cursor: pointer; border-radius: 2px;
  transition: all 0.2s;
}
.rpt-refresh:hover { border-color: #aacc00; color: #ccee44; }

/* ── Overlay Visiteurs ── */
.vis-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.88);
  z-index: 500;
  align-items: center;
  justify-content: center;
  padding: 16px;
}
.vis-overlay.visible { display: flex; }
.vis-panel {
  background: #08080a;
  border: 1px solid #ffaa00;
  border-radius: 4px;
  width: 100%;
  max-width: 720px;
  max-height: 90vh;
  overflow-y: auto;
  font-family: 'Space Mono','Courier New',monospace;
  color: #ffcc44;
  box-shadow: 0 0 30px #ffaa0022;
}
.vp-header {
  background: #1a1000;
  border-bottom: 1px solid #ffaa00;
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  letter-spacing: 2px;
  font-size: 0.8em;
  font-weight: bold;
  text-shadow: 0 0 6px #ffaa00;
}
.vp-close {
  background: transparent;
  border: 1px solid #cc8800;
  color: #ffcc44;
  font-family: inherit;
  font-size: 0.9em;
  padding: 2px 8px;
  cursor: pointer;
  border-radius: 2px;
}
.vp-close:hover { background: #ffaa0011; }
.vp-section { padding: 12px 16px; }
.vp-summary {
  display: flex;
  gap: 20px;
  flex-wrap: wrap;
  margin-bottom: 14px;
}
.vp-stat {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.vp-stat-label { font-size: 0.55em; color: #886600; letter-spacing: 2px; }
.vp-stat-val { font-size: 1.1em; color: #ffdd77; text-shadow: 0 0 6px #ffaa0066; }
.vp-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.6em;
  letter-spacing: 0.3px;
}
.vp-table th {
  text-align: left;
  color: #cc8800;
  border-bottom: 1px solid #443300;
  padding: 5px 8px;
  letter-spacing: 1.5px;
  font-size: 0.95em;
  white-space: nowrap;
}
.vp-table td {
  padding: 6px 8px;
  border-bottom: 1px solid #221a00;
  vertical-align: middle;
  color: #ddbb55;
}
.vp-table tr:hover td { background: #1a1000; }
.vp-table td.vp-name { color: #ffdd77; font-weight: bold; }
.vp-table td.vp-ip { color: #886600; font-size: 0.9em; }
.vp-table td.vp-mac { color: #554400; font-size: 0.85em; }
.vp-table td.vp-visits { color: #ffaa44; text-align: center; }
.vp-table td.vp-lang { color: #cc8800; text-align: center; }
.vp-badge-online {
  display: inline-block;
  width: 7px; height: 7px;
  border-radius: 50%;
  background: #00ff88;
  box-shadow: 0 0 4px #00ff88;
  margin-right: 5px;
}
.vp-footer { display: flex; justify-content: flex-end; padding: 10px 16px; border-top: 1px solid #332200; }

/* ── Bouton Night Scheduler (dans header, à gauche de VIG) ── */
.night-btn {
  position: relative; transform: none;
  background: transparent;
  border: 1px solid #002244;
  color: #003366;
  font-size: 0.48em;
  font-family: inherit;
  font-weight: bold;
  letter-spacing: 1.5px;
  padding: 3px 7px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.3s;
  -webkit-tap-highlight-color: transparent;
}
.night-btn:hover { color: #0088ff; border-color: #0055cc; box-shadow: 0 0 8px #0055ff33; }
.night-btn.active { color: #44aaff; border-color: #0077ee; box-shadow: 0 0 10px #0055ff44; }

/* ── Overlay Night Scheduler ── */
.night-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.85);
  z-index: 500;
  align-items: center;
  justify-content: center;
  padding: 16px;
}
.night-overlay.visible { display: flex; }
.night-panel {
  background: rgba(2,12,6,0.97);
  border: 1px solid rgba(0,255,136,0.4);
  border-radius: 6px;
  padding: 0;
  width: 100%;
  max-width: 560px;
  max-height: 90vh;
  overflow-y: auto;
  font-family: 'Courier New', monospace;
  color: #00cc77;
  box-shadow: 0 0 40px rgba(0,255,136,0.1), inset 0 0 30px rgba(0,20,10,0.5);
  backdrop-filter: blur(8px);
}
.np-header {
  background: rgba(0,30,15,0.95);
  border-bottom: 1px solid rgba(0,255,136,0.25);
  padding: 12px 18px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  letter-spacing: 3px;
  font-size: 0.72em;
  font-weight: bold;
  text-shadow: 0 0 10px rgba(0,255,136,0.5);
  color: #00ff88;
}
.np-close {
  background: transparent;
  border: 1px solid #00cc66;
  color: #00ff88;
  font-family: inherit;
  font-size: 0.9em;
  padding: 2px 8px;
  cursor: pointer;
  border-radius: 2px;
}
.np-close:hover { background: #00ff8811; }
.np-section {
  padding: 14px 18px;
  border-bottom: 1px solid rgba(0,100,50,0.2);
}
.np-label {
  font-size: 0.55em;
  letter-spacing: 3px;
  color: #008844;
  margin-bottom: 10px;
  text-transform: uppercase;
  border-left: 2px solid rgba(0,255,136,0.3);
  padding-left: 8px;
}
.np-daemon-row {
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}
.np-status-badge {
  font-size: 0.72em;
  letter-spacing: 1.5px;
  padding: 3px 10px;
  border-radius: 2px;
  border: 1px solid #00ff88;
  background: #001a0d;
  text-shadow: 0 0 6px #00ff88;
}
.np-status-badge.off {
  border-color: #224422;
  color: #336633;
  text-shadow: none;
}
.np-btn {
  background: transparent;
  border: 1px solid #00cc66;
  color: #00ff88;
  font-family: inherit;
  font-size: 0.65em;
  letter-spacing: 1px;
  padding: 4px 12px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.2s;
}
.np-btn:hover { background: #00ff8822; box-shadow: 0 0 8px #00ff8833; }
.np-btn.danger { border-color: #ff4444; color: #ff6666; }
.np-btn.danger:hover { background: #ff000022; }
.np-windows-list { margin-top: 6px; display: flex; flex-direction: column; gap: 6px; }
.np-window-item {
  display: flex;
  align-items: center;
  gap: 8px;
  background: #001a0d;
  border: 1px solid #003322;
  border-radius: 2px;
  padding: 6px 10px;
  font-size: 0.65em;
  letter-spacing: 0.5px;
  flex-wrap: wrap;
}
.np-window-item.disabled { opacity: 0.45; }
.np-win-name { flex: 1; min-width: 80px; color: #00ff88; font-weight: bold; }
.np-win-info { color: #008844; font-size: 0.9em; }
.np-toggle-btn {
  background: transparent;
  border: 1px solid #007744;
  color: #00cc66;
  font-family: inherit;
  font-size: 1em;
  padding: 1px 7px;
  cursor: pointer;
  border-radius: 2px;
}
.np-toggle-btn:hover { background: #00ff8811; }
.np-del-btn {
  background: transparent;
  border: 1px solid #440000;
  color: #884444;
  font-family: inherit;
  font-size: 1em;
  padding: 1px 7px;
  cursor: pointer;
  border-radius: 2px;
}
.np-del-btn:hover { color: #ff4444; border-color: #ff2222; }
.np-empty { font-size: 0.65em; color: #226633; letter-spacing: 1px; }
.np-form {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
  margin-top: 6px;
}
.np-form-row {
  display: flex;
  flex-direction: column;
  gap: 3px;
}
.np-form-row label { font-size: 0.58em; color: #00cc66; letter-spacing: 1px; }
.np-input {
  background: #001a0d;
  border: 1px solid #005533;
  color: #00ff88;
  font-family: inherit;
  font-size: 0.7em;
  padding: 4px 8px;
  border-radius: 2px;
  width: 100%;
  box-sizing: border-box;
}
.np-input:focus { outline: none; border-color: #00ff88; box-shadow: 0 0 6px #00ff8833; }
.np-days-row {
  grid-column: 1 / -1;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  align-items: center;
}
.np-days-row label { font-size: 0.58em; color: #00cc66; letter-spacing: 1px; margin-right: 4px; }
.np-day-btn {
  background: transparent;
  border: 1px solid #003322;
  color: #336633;
  font-family: inherit;
  font-size: 0.6em;
  padding: 2px 6px;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.15s;
}
.np-day-btn.sel { border-color: #00cc66; color: #00ff88; background: #001a0d; text-shadow: 0 0 4px #00ff8866; }
.np-form-full { grid-column: 1 / -1; display: flex; justify-content: flex-end; }
.np-runnow-row { display: flex; align-items: center; gap: 10px; margin-top: 6px; }
.np-logs-box {
  background: #010e07;
  border: 1px solid #003322;
  border-radius: 2px;
  padding: 8px 10px;
  margin-top: 6px;
  max-height: 150px;
  overflow-y: auto;
  font-size: 0.58em;
  line-height: 1.6;
  color: #00aa55;
  letter-spacing: 0.3px;
  white-space: pre-wrap;
  word-break: break-all;
}
.np-logs-footer { display: flex; justify-content: flex-end; margin-top: 6px; }

/* ── Alerte vigilance dans le chat ── */
.message.vigilance-alert {
  background: #1a0003;
  border: 1px solid #ff2244;
  border-left: 3px solid #ff0033;
  color: #ff6677;
  font-style: italic;
  animation: vig-flash 0.6s ease-in-out 3;
}
.message.vigilance-alert::before {
  content: '[ VIGILANCE ]';
  color: #ff2244;
  font-weight: bold;
  display: block;
  margin-bottom: 4px;
  letter-spacing: 2px;
  font-style: normal;
}
@keyframes vig-flash {
  0%,100% { background: #1a0003; border-color: #ff2244; }
  50% { background: #2d0008; border-color: #ff5566; box-shadow: 0 0 12px #ff004455; }
}

/* ── Badge langue dans status-bar ── */
#lang-badge {
  display: none;
  margin-left: 8px;
  padding: 0 5px;
  border: 1px solid rgba(0,180,60,0.4);
  background: rgba(0,20,0,0.6);
  color: #00cc44;
  font-size: 0.88em;
  letter-spacing: 1.5px;
  border-radius: 2px;
  vertical-align: middle;
}
#lang-badge.visible { display: inline-block; }

/* ── Header MU-TH-UR 6000 — ligne verte phosphore ── */
.mother-line {
  font-size: 0.5em;
  color: #008833;
  letter-spacing: 3px;
  text-transform: uppercase;
  margin-top: 3px;
  text-shadow: 0 0 8px #00ff2233;
  animation: mother-flicker 9s ease-in-out infinite;
}
@keyframes mother-flicker {
  0%,100% { opacity: 0.65; }
  42%   { opacity: 0.6; }
  43%   { opacity: 0.9; }
  44%   { opacity: 0.6; }
  78%   { opacity: 0.65; }
  79%   { opacity: 1.0; }
  80%   { opacity: 0.65; }
}

/* ── Panneau connexions temps réel (translucide) ── */
.conn-panel {
  position: fixed;
  top: 50%; left: 0;
  transform: translateY(-50%);
  width: 185px;
  background: rgba(0,5,0,0.78);
  border-right: 1px solid rgba(0,180,60,0.2);
  border-top: 1px solid rgba(0,180,60,0.1);
  border-bottom: 1px solid rgba(0,180,60,0.1);
  font-family: 'Courier New', monospace;
  font-size: 0.48em;
  color: #00aa33;
  letter-spacing: 0.8px;
  line-height: 1.65;
  pointer-events: none;
  z-index: 3;
  padding: 10px 10px 12px;
  opacity: 0.75;
}
.conn-panel .cp-title {
  color: #00dd44;
  letter-spacing: 2.5px;
  border-bottom: 1px solid rgba(0,180,60,0.25);
  padding-bottom: 4px;
  margin-bottom: 6px;
  font-size: 1.05em;
}
.conn-panel .cp-stat { display: flex; justify-content: space-between; }
.conn-panel .cp-label { color: #006622; }
.conn-panel .cp-val { color: #00ff55; }
.conn-panel .cp-sep { border-top: 1px solid rgba(0,100,30,0.2); margin: 5px 0; }
.conn-panel .cp-ip { color: #008833; word-break: break-all; }
.conn-panel .cp-name { color: #00cc44; }
.conn-panel { display: none !important; }
@media (max-width: 700px) { .conn-panel { display: none; } }

/* ── Mode paysage mobile ── */
@media (max-width: 768px) and (orientation: landscape) {
  .header { padding: 5px 10px; }
  .header h1 { font-size: 1em; letter-spacing: 2px; }
  .header .subtitle { display: none; }
  .scanner-container { padding: 5px 20px; }
  .voicebox-container { padding: 0 20px 3px; }
  .input-area {
    padding: 5px 10px;
    padding-bottom: max(5px, env(safe-area-inset-bottom));
    gap: 5px;
  }
  .mic-btn, .auto-btn, .wake-btn, .cam-btn, .audio-btn { width: 36px; height: 36px; }
  .chat-area { padding: 6px 10px; gap: 6px; }
}
</style>
</head>
<body>
<div class="scan-beam" aria-hidden="true"></div>

<div id="jarvis-bg" aria-hidden="true">
  <svg id="jarvis-svg" viewBox="-200 -200 400 400" xmlns="http://www.w3.org/2000/svg">

    <!-- ── Anneaux HUD extérieurs ── -->
    <circle r="175" fill="none" stroke="#ff2200" stroke-width="0.5" stroke-opacity="0.45">
      <animateTransform attributeName="transform" type="rotate"
        from="0 0 0" to="360 0 0" dur="70s" repeatCount="indefinite"/>
    </circle>
    <circle r="175" fill="none" stroke="#ff3300" stroke-width="0.8"
            stroke-dasharray="10 30" stroke-opacity="0.55">
      <animateTransform attributeName="transform" type="rotate"
        from="360 0 0" to="0 0 0" dur="50s" repeatCount="indefinite"/>
    </circle>
    <circle r="125" fill="none" stroke="#cc2200" stroke-width="0.4" stroke-opacity="0.35">
      <animateTransform attributeName="transform" type="rotate"
        from="360 0 0" to="0 0 0" dur="45s" repeatCount="indefinite"/>
    </circle>
    <circle r="125" fill="none" stroke="#ff4400" stroke-width="0.6"
            stroke-dasharray="5 18" stroke-opacity="0.5">
      <animateTransform attributeName="transform" type="rotate"
        from="0 0 0" to="360 0 0" dur="32s" repeatCount="indefinite"/>
    </circle>

    <!-- Spokes r=125 → r=64 (s'arrêtent à la surface de la sphère) -->
    <g stroke="#880000" stroke-width="0.35" stroke-opacity="0.32">
      <line x1="0" y1="-125" x2="0" y2="-64"/>
      <line x1="88" y1="-88" x2="46" y2="-46"/>
      <line x1="125" y1="0" x2="64" y2="0"/>
      <line x1="88" y1="88" x2="46" y2="46"/>
      <line x1="0" y1="125" x2="0" y2="64"/>
      <line x1="-88" y1="88" x2="-46" y2="46"/>
      <line x1="-125" y1="0" x2="-64" y2="0"/>
      <line x1="-88" y1="-88" x2="-46" y2="-46"/>
      <animateTransform attributeName="transform" type="rotate"
        from="0 0 0" to="360 0 0" dur="100s" repeatCount="indefinite"/>
    </g>

    <!-- Marqueurs HUD (4 coins) -->
    <g stroke="#ff3300" stroke-width="0.7" stroke-opacity="0.5" fill="none">
      <path d="M -148 -162 L -162 -162 L -162 -148"/>
      <path d="M 148 -162 L 162 -162 L 162 -148"/>
      <path d="M -148 162 L -162 162 L -162 148"/>
      <path d="M 148 162 L 162 162 L 162 148"/>
    </g>

    <!-- Arc scanner (anneau 125) -->
    <path d="M 0,-125 A 125,125 0 0,1 88,-88"
          fill="none" stroke="#ff4400" stroke-width="1.2"
          stroke-opacity="0.6" stroke-linecap="round">
      <animateTransform attributeName="transform" type="rotate"
        from="0 0 0" to="360 0 0" dur="8s" repeatCount="indefinite"/>
    </path>

    <!-- Textes HUD -->
    <text y="-183" text-anchor="middle"
          font-family="'Courier New',monospace" font-size="5.5"
          fill="#aa2200" fill-opacity="0.35" letter-spacing="3">KNIGHT INDUSTRIES</text>
    <text y="191" text-anchor="middle"
          font-family="'Courier New',monospace" font-size="5.5"
          fill="#aa2200" fill-opacity="0.35" letter-spacing="3">KYRONEX A.I. SYSTEM</text>

  </svg>
</div>

<!-- Sphère holographique 3D CSS (vrai rendu perspective) -->
<div id="sphere-wrap" aria-hidden="true">
  <div id="sphere-3d">
    <!-- 6 méridiens longitudinaux espacés de 30° -->
    <div class="s-mer" style="--r:0deg"></div>
    <div class="s-mer" style="--r:30deg"></div>
    <div class="s-mer" style="--r:60deg"></div>
    <div class="s-mer" style="--r:90deg"></div>
    <div class="s-mer" style="--r:120deg"></div>
    <div class="s-mer" style="--r:150deg"></div>
    <!-- 7 parallèles latitudinaux (sphère R=110px) -->
    <!-- équateur -->
    <div class="s-par" style="width:220px;height:220px;top:0;left:0;--ty:0px"></div>
    <!-- ±26° : R*cos26°=99px, R*sin26°=48px -->
    <div class="s-par" style="width:198px;height:198px;top:11px;left:11px;--ty:-48px"></div>
    <div class="s-par" style="width:198px;height:198px;top:11px;left:11px;--ty:48px"></div>
    <!-- ±52° : R*cos52°=68px, R*sin52°=87px -->
    <div class="s-par" style="width:135px;height:135px;top:42px;left:42px;--ty:-87px"></div>
    <div class="s-par" style="width:135px;height:135px;top:42px;left:42px;--ty:87px"></div>
    <!-- ±72° : R*cos72°=34px, R*sin72°=105px -->
    <div class="s-par" style="width:68px;height:68px;top:76px;left:76px;--ty:-105px"></div>
    <div class="s-par" style="width:68px;height:68px;top:76px;left:76px;--ty:105px"></div>
    <!-- Noyau central pulsant -->
    <div class="s-core"></div>
  </div>
</div>

<canvas id="orb" aria-hidden="true"></canvas>

<div class="header">
  <h1>K I T T</h1>
  <div class="subtitle">KNIGHT INDUSTRIES TWO THOUSAND &nbsp;·&nbsp; KYRONEX A.I. &nbsp;·&nbsp; by Manix</div>
  <div class="mother-line">MU-TH-UR 6000 &nbsp;·&nbsp; NEURAL INTERFACE ACTIVE</div>
  <div class="header-btns">
    <button class="reset-btn" id="resetbtn" onclick="resetChat()" title="Vider l'historique KITT">RST</button>
    <button class="vig-btn" id="vigbtn" onclick="_requireNightAuth(toggleVigilance)" title="Mode Vigilance — surveillance caméra">VIG</button>
    <button class="ambient-btn" id="ambientbtn" onclick="_requireNightAuth(toggleAmbient)" title="Sons d'ambiance système">AMB</button>
    <button class="night-btn" id="nightbtn" onclick="toggleNightPanel()" title="Night Scheduler — améliorations autonomes">NIGHT</button>
    <button class="vis-btn" id="visbtn" onclick="toggleVisPanel()" title="Visiteurs — historique des connexions">VIS</button>
    <button class="rpt-btn" id="rptbtn" onclick="_requireNightAuth(toggleRptPanel)" title="Rapport Mode Automatique — historique des améliorations autonomes">RPT</button>
    <button class="enhance-btn" id="enhancebtn" onclick="_requireNightAuth(toggleEnhance)" title="Lance une optimisation graphique et vocale complète du site actif sans supprimer le contenu existant.">AUTO</button>
    <button class="dl-btn" id="dlbtn" onclick="_requireNightAuth(downloadHtml)" title="Télécharger le index.html actuel">DL</button>
    <button class="git-btn" id="gitbtn" onclick="_requireNightAuth(gitPushHtml)" title="Pousser index.html vers GitHub">GIT</button>
    <button class="run-btn" id="runbtn" onclick="_requireNightAuth(runImprove)" title="Lancer une amélioration autonome maintenant">RUN</button>
  </div>
</div>

<div class="scanner-container">
  <div class="scanner" id="scanner">
    <div class="scanner-trail" id="scannerTrail"></div>
    <div class="scanner-head" id="scannerHead"></div>
  </div>
</div>

<div class="voicebox-container">
  <canvas id="voicebox" width="280" height="44"></canvas>
</div>

<div class="mobile-stats" id="mobileStats">
  <span id="ms-online">—</span> en ligne &nbsp;·&nbsp;
  <span id="ms-health" class="online">INIT</span>
</div>

<div class="chat-area" id="chat"></div>

<div class="input-area">
  <button class="mic-btn" id="mic" onclick="toggleMic()" title="Push-to-talk">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm-1-9c0-.55.45-1 1-1s1 .45 1 1v6c0 .55-.45 1-1 1s-1-.45-1-1V5z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
  </button>
  <button class="auto-btn" id="automic" onclick="toggleAutoListen()" title="Auto-ecoute continue">AUTO</button>
  <button class="wake-btn" id="wakemic" onclick="toggleWakeListen()" title="Wake word: dites KITT">WAKE</button>
  <button class="cam-btn" id="cam" onclick="sendVision()" title="Vision camera">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 15.2a3.2 3.2 0 1 0 0-6.4 3.2 3.2 0 0 0 0 6.4z"/><path d="M9 2L7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></svg>
  </button>
  <button class="audio-btn" id="audiobtn" onclick="activateAudio()" title="Activer le son">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
    <svg class="slash" width="20" height="20" viewBox="0 0 24 24" style="position:absolute"><line x1="4" y1="4" x2="20" y2="20" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/></svg>
  </button>
  <input type="text" id="input" placeholder="Parlez à KITT..." autofocus>
  <button id="send" onclick="sendMessage()">ENVOYER</button>
</div>

<div class="status-bar">
  <span id="status">Connexion...</span><span id="lang-badge"></span>
</div>

<script>
const chat = document.getElementById('chat');
const input = document.getElementById('input');
const scanner = document.getElementById('scanner');
const sendBtn = document.getElementById('send');
const statusEl = document.getElementById('status');
const sessionId = 'kyronex-' + Date.now();
let isRecording = false;
let micStream = null;
let micProcessor = null;
let micContext = null;
let pcmChunks = [];
const micBtn = document.getElementById('mic');
const autoBtn = document.getElementById('automic');
const wakeBtn = document.getElementById('wakemic');

// Auto-listen state
let autoListenActive = false;
let autoStream = null;
let autoContext = null;
let autoProcessor = null;
let autoAnalyser = null;
let autoPcmChunks = [];
let isSpeaking = false;
let silenceStart = 0;
const VAD_THRESHOLD = 0.015;
const SILENCE_DURATION = 1200;
const MIN_SPEECH_DURATION = 600;
let speechStart = 0;
let autoProcessing = false;

input.addEventListener('keydown', e => { if (e.key === 'Enter' && !sendBtn.disabled) sendMessage(); });
input.addEventListener('input', () => { sendBtn.classList.toggle('ready', input.value.trim().length > 0); });

const CHAT_HISTORY_KEY = 'kyronex_chat_history';
const CHAT_HISTORY_MAX = 20;

function _saveChatHistory(html, who) {
  try {
    const h = JSON.parse(localStorage.getItem(CHAT_HISTORY_KEY) || '[]');
    h.push({ html, who, ts: Date.now() });
    while (h.length > CHAT_HISTORY_MAX) h.shift();
    localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(h));
  } catch(e) {}
}

function _loadChatHistory() {
  try {
    const h = JSON.parse(localStorage.getItem(CHAT_HISTORY_KEY) || '[]');
    if (!h.length) return;
    const sep = document.createElement('div');
    sep.className = 'message';
    sep.style.cssText = 'color:#222;font-size:0.6em;text-align:center;letter-spacing:2px;border:none;align-self:center;';
    sep.textContent = '— HISTORIQUE —';
    chat.appendChild(sep);
    h.forEach(m => {
      const div = document.createElement('div');
      div.className = 'message ' + m.who;
      div.innerHTML = m.html;
      chat.appendChild(div);
    });
    chat.scrollTop = chat.scrollHeight;
  } catch(e) {}
}

function addMessage(text, who, timing) {
  const div = document.createElement('div');
  div.className = 'message ' + who;
  let html = text;
  if (timing) html += `<div class="timing">LLM: ${timing.llm_ms}ms | TTS: ${timing.tts_ms}ms | Total: ${timing.total_ms}ms</div>`;
  div.innerHTML = html;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
  if (who === 'user' || who === 'kitt') _saveChatHistory(html, who);
}

async function sendMessage() {
  const msg = input.value.trim();
  if (!msg) return;

  addMessage(msg, 'user');
  input.value = '';
  sendBtn.classList.remove('ready');
  sendBtn.disabled = true;
  sendBtn.classList.add('sending');
  await streamChat(msg);
  sendBtn.classList.remove('sending');
}

let _lastDetectedLang = '';   // langue détectée par Whisper STT

async function streamChat(msg, detectedLang) {
  const div = document.createElement('div');
  div.className = 'message kitt';
  div.innerHTML = '<span class="typing">...</span>';
  chat.appendChild(div);

  startThinkingLoop();
  resetAudioQueue();
  _revealDiv = div;
  let firstChunk = true;
  let text = '';

  // Langue : préférence stockée > Whisper > auto
  const chatBody = { message: msg, session_id: sessionId };
  const lang = _preferredLang || detectedLang || _lastDetectedLang;
  if (lang) chatBody.lang = lang;

  try {
    const res = await fetch('/api/chat/stream', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(chatBody)
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            if (data.token) {
              text += data.token;
            }
            if (data.audio_chunk) {
              if (firstChunk) { stopThinkingLoop(); firstChunk = false; }
              queueAudioChunk(data.audio_chunk, data.chunk_text || '');
            }
            if (data.done) {
              stopThinkingLoop();
              if (data.timing && data.timing.emotion) applyEmotion(data.timing.emotion);
              let timingHtml = '';
              if (data.timing) {
                let t = data.timing.vision_ms ? `Vision: ${data.timing.vision_ms}ms | ` : '';
                timingHtml = `<div class="timing">${t}LLM: ${data.timing.llm_ms}ms | TTS: ${data.timing.tts_ms || 0}ms</div>`;
              }
              // Si pas d'audio reçu, afficher le texte directement
              if (firstChunk) {
                div.innerHTML = text + timingHtml;
                chat.scrollTop = chat.scrollHeight;
              } else {
                // Le timing sera ajouté quand la lecture audio sera terminée
                _waitForAudioDone(div, text, timingHtml);
              }
            }
          } catch (err) {
            if (text && div.innerHTML.includes('typing')) {
              div.innerHTML = text;
              chat.scrollTop = chat.scrollHeight;
            }
            console.error('SSE parse/reveal error:', err);
          }
        }
      }
    }
  } catch (e) {
    stopThinkingLoop();
    div.innerHTML = 'Erreur de connexion au serveur.';
  }
  stopThinkingLoop();
  sendBtn.disabled = false;
  sendBtn.classList.remove('sending');
  input.focus();
}

function _waitForAudioDone(div, fullText, timingHtml) {
  const check = setInterval(() => {
    if (!_chunkPlaying && _chunkQueue.length === 0) {
      clearInterval(check);
      div.innerHTML = fullText + timingHtml;
      chat.scrollTop = chat.scrollHeight;
      playEndOfMessageSound();
    }
  }, 200);
}

const camBtn = document.getElementById('cam');

async function sendVision() {
  const msg = input.value.trim() || 'Que vois-tu ?';
  addMessage(msg, 'user');
  input.value = '';
  sendBtn.disabled = true;
  camBtn.disabled = true;
  camBtn.classList.add('capturing');
  statusEl.innerHTML = `<span class="online">${_t('camera_capture')}</span>`;

  const div = document.createElement('div');
  div.className = 'message kitt';
  div.innerHTML = '<span class="typing">Analyse visuelle...</span>';
  chat.appendChild(div);

  startThinkingLoop();
  resetAudioQueue();
  _revealDiv = div;
  let visionFirstChunk = true;
  let text = '';

  try {
    const res = await fetch('/api/vision', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ message: msg, session_id: sessionId })
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop();
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            if (data.token) {
              text += data.token;
            }
            if (data.audio_chunk) {
              if (visionFirstChunk) { stopThinkingLoop(); visionFirstChunk = false; }
              queueAudioChunk(data.audio_chunk, data.chunk_text || '');
            }
            if (data.done) {
              stopThinkingLoop();
              if (data.timing && data.timing.emotion) applyEmotion(data.timing.emotion);
              let timingHtml = '';
              if (data.timing) {
                timingHtml = `<div class="timing">Vision: ${data.timing.vision_ms || 0}ms | LLM: ${data.timing.llm_ms}ms | TTS: ${data.timing.tts_ms || 0}ms</div>`;
              }
              if (visionFirstChunk) {
                div.innerHTML = text + timingHtml;
                chat.scrollTop = chat.scrollHeight;
              } else {
                _waitForAudioDone(div, text, timingHtml);
              }
            }
          } catch (err) {
            if (text && div.innerHTML.includes('typing')) {
              div.innerHTML = text;
              chat.scrollTop = chat.scrollHeight;
            }
            console.error('Vision SSE/reveal error:', err);
          }
        }
      }
    }
  } catch (e) {
    stopThinkingLoop();
    div.innerHTML = 'Erreur de connexion au serveur.';
  }
  stopThinkingLoop();
  camBtn.classList.remove('capturing');
  camBtn.disabled = false;
  sendBtn.disabled = false;
  input.focus();
}

let playbackCtx = null;
function ensurePlaybackCtx() {
  if (!playbackCtx || playbackCtx.state === 'closed') {
    playbackCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (playbackCtx.state === 'suspended') playbackCtx.resume();
  return playbackCtx;
}
// Unlock audio on any user interaction
['click', 'touchstart', 'keydown'].forEach(evt =>
  document.addEventListener(evt, () => ensurePlaybackCtx(), { once: false })
);

function playAudio(url) {
  scanner.classList.add('speaking');
  const ctx = ensurePlaybackCtx();
  fetch(url)
    .then(r => r.arrayBuffer())
    .then(buf => ctx.decodeAudioData(buf))
    .then(decoded => {
      const src = ctx.createBufferSource();
      src.buffer = decoded;
      src.connect(ctx.destination);
      src.onended = () => scanner.classList.remove('speaking');
      src.start(0);
    })
    .catch(() => {
      // Fallback to Audio element
      const audio = new Audio(url);
      audio.onended = () => scanner.classList.remove('speaking');
      audio.onerror = () => scanner.classList.remove('speaking');
      audio.play().catch(() => scanner.classList.remove('speaking'));
    });
}

// ── Audio chunk queue + reveal synchronisé ────────────────────
let _chunkQueue = [];    // [{url, text}]
let _chunkPlaying = false;
let _revealDiv = null;
let _revealedText = '';

function queueAudioChunk(url, chunkText) {
  _chunkQueue.push({url: url, text: chunkText});
  if (!_chunkPlaying && _revealDiv) _playAndRevealNext();
}

async function _playAndRevealNext() {
  if (_chunkQueue.length === 0) {
    _chunkPlaying = false;
    scanner.classList.remove('speaking');
    return;
  }
  _chunkPlaying = true;
  scanner.classList.add('speaking');
  const {url, text} = _chunkQueue.shift();
  const ctx = ensurePlaybackCtx();
  try {
    const resp = await fetch(url);
    const buf = await resp.arrayBuffer();
    const decoded = await ctx.decodeAudioData(buf);
    const durationMs = decoded.duration * 1000;

    const src = ctx.createBufferSource();
    src.buffer = decoded;
    const vbAnalyser = ensureVoiceboxAnalyser();
    src.connect(vbAnalyser);
    src.onended = () => _playAndRevealNext();
    src.start(0);
    startVoicebox();

    // Reveal chunk text word by word synced to audio duration
    const parts = text.split(/(\s+)/);
    const wordCount = parts.filter(p => p.trim()).length;
    const msPerWord = Math.max(60, durationMs / wordCount);
    for (const part of parts) {
      _revealedText += part;
      if (part.trim()) {
        _revealDiv.innerHTML = _revealedText;
        chat.scrollTop = chat.scrollHeight;
        await new Promise(r => setTimeout(r, msPerWord));
      }
    }
  } catch {
    // Fallback: show text immediately
    _revealedText += text + ' ';
    if (_revealDiv) { _revealDiv.innerHTML = _revealedText; chat.scrollTop = chat.scrollHeight; }
    _playAndRevealNext();
  }
}

// ── Voicebox KITT — visualiseur vocal temps réel ──────────────
const VB_BARS = 14;
const VB_W = 280;
const VB_H = 44;
let voiceboxAnalyser = null;
let voiceboxRAF = null;

function ensureVoiceboxAnalyser() {
  const ctx = ensurePlaybackCtx();
  if (!voiceboxAnalyser || voiceboxAnalyser.context.state === 'closed') {
    voiceboxAnalyser = ctx.createAnalyser();
    voiceboxAnalyser.fftSize = 128;
    voiceboxAnalyser.smoothingTimeConstant = 0.78;
    voiceboxAnalyser.connect(ctx.destination);
  }
  return voiceboxAnalyser;
}

function drawVoicebox() {
  const canvas = document.getElementById('voicebox');
  const cc = canvas.getContext('2d');
  cc.clearRect(0, 0, VB_W, VB_H);

  const bufLen = voiceboxAnalyser.frequencyBinCount;
  const data = new Uint8Array(bufLen);
  voiceboxAnalyser.getByteFrequencyData(data);

  const totalGap = (VB_BARS - 1) * 3;
  const bW = Math.floor((VB_W - totalGap) / VB_BARS);

  for (let i = 0; i < VB_BARS; i++) {
    // Focaliser sur les fréquences vocales (basses/médiums)
    const idx = Math.floor((i / VB_BARS) * bufLen * 0.6);
    const val = data[idx] / 255.0;
    const barH = Math.max(3, val * VB_H * 0.92);
    const x = i * (bW + 3);
    const y = (VB_H - barH) / 2;

    // Glow rouge KITT
    cc.shadowColor = '#ff2200';
    cc.shadowBlur = val * 16;
    cc.fillStyle = `rgba(255, ${Math.floor(val * 70)}, 0, ${0.4 + val * 0.6})`;
    cc.fillRect(x, y, bW, barH);
  }

  if (scanner.classList.contains('speaking')) {
    voiceboxRAF = requestAnimationFrame(drawVoicebox);
  } else {
    voiceboxRAF = null;
    _drawVoiceboxIdle();
  }
}

function _drawVoiceboxIdle() {
  const canvas = document.getElementById('voicebox');
  if (!canvas) return;
  const cc = canvas.getContext('2d');
  cc.clearRect(0, 0, VB_W, VB_H);
  cc.shadowBlur = 0;
  const totalGap = (VB_BARS - 1) * 3;
  const bW = Math.floor((VB_W - totalGap) / VB_BARS);
  for (let i = 0; i < VB_BARS; i++) {
    cc.fillStyle = 'rgba(180, 40, 0, 0.75)';
    cc.fillRect(i * (bW + 3), VB_H / 2 - 1, bW, 2);
  }
}

function startVoicebox() {
  ensureVoiceboxAnalyser();
  if (!voiceboxRAF) voiceboxRAF = requestAnimationFrame(drawVoicebox);
}

function resetAudioQueue() {
  _chunkQueue = [];
  _chunkPlaying = false;
  _revealDiv = null;
  _revealedText = '';
}

function encodeWAV(samples, sampleRate) {
  const buf = new ArrayBuffer(44 + samples.length * 2);
  const view = new DataView(buf);
  function writeStr(off, s) { for (let i = 0; i < s.length; i++) view.setUint8(off + i, s.charCodeAt(i)); }
  writeStr(0, 'RIFF');
  view.setUint32(4, 36 + samples.length * 2, true);
  writeStr(8, 'WAVE');
  writeStr(12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, 1, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * 2, true);
  view.setUint16(32, 2, true);
  view.setUint16(34, 16, true);
  writeStr(36, 'data');
  view.setUint32(40, samples.length * 2, true);
  for (let i = 0; i < samples.length; i++) {
    const s = Math.max(-1, Math.min(1, samples[i]));
    view.setInt16(44 + i * 2, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return new Blob([buf], { type: 'audio/wav' });
}

async function sendToSTT(chunks, sampleRate) {
  const allSamples = new Float32Array(chunks.reduce((a, b) => a + b.length, 0));
  let offset = 0;
  for (const chunk of chunks) { allSamples.set(chunk, offset); offset += chunk.length; }

  const wavBlob = encodeWAV(allSamples, sampleRate);
  statusEl.innerHTML = '<span class="online">Transcription... (' + (wavBlob.size/1024).toFixed(0) + ' Ko)</span>';

  const formData = new FormData();
  formData.append('audio', wavBlob, 'recording.wav');

  const res = await fetch('/api/stt', { method: 'POST', body: formData });
  return await res.json();
}

async function handleSTTResult(data) {
  if (data.text && data.text.trim()) {
    const text = data.text.trim();
    // Sauvegarder la langue détectée par Whisper pour l'envoyer au serveur
    _updateLangDetection(data.language || '', text, 'whisper-stt');
    addMessage(text, 'user', null);
    const langInfo = data.language ? ` · ${data.language.toUpperCase()}` : '';
    statusEl.innerHTML = `<span class="online">STT: ${data.stt_ms}ms${langInfo}</span>`;
    sendBtn.disabled = true;
    await streamChat(text, data.language || '');
    return true;
  }
  return false;
}

// ── Mode 1: Push-to-talk ──────────────────────────────────────

async function stopRecording() {
  if (!isRecording) return;
  isRecording = false;
  micBtn.classList.remove('recording');
  micBtn.classList.add('transcribing');
  scanner.classList.remove('listening');

  if (micProcessor) micProcessor.disconnect();
  if (micStream) micStream.getTracks().forEach(t => t.stop());
  if (micContext) micContext.close();

  try {
    const data = await sendToSTT(pcmChunks, 16000);
    if (!await handleSTTResult(data)) {
      statusEl.innerHTML = `<span class="offline">${_t('stt_nothing')}</span>`;
    }
  } catch (e) {
    statusEl.innerHTML = `<span class="offline">${_t('stt_error')}</span>`;
  }
  micBtn.classList.remove('transcribing');
}

function getUserMediaCompat(constraints) {
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    return navigator.mediaDevices.getUserMedia(constraints);
  }
  const legacyGetUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
  if (legacyGetUserMedia) {
    return new Promise((resolve, reject) => legacyGetUserMedia.call(navigator, constraints, resolve, reject));
  }
  return Promise.reject(new Error('getUserMedia non supporte par ce navigateur'));
}

async function toggleMic() {
  if (autoListenActive) stopAutoListen();
  if (wakeListenActive) stopWakeListen();
  if (isRecording) { stopRecording(); return; }

  try {
    statusEl.innerHTML = '<span class="online">Demande micro...</span>';
    micStream = await getUserMediaCompat({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true } });

    micContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
    const source = micContext.createMediaStreamSource(micStream);
    micProcessor = micContext.createScriptProcessor(4096, 1, 1);
    pcmChunks = [];

    micProcessor.onaudioprocess = (e) => {
      if (isRecording) pcmChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
    };

    source.connect(micProcessor);
    micProcessor.connect(micContext.destination);

    isRecording = true;
    micBtn.classList.add('recording');
    scanner.classList.add('listening');
    statusEl.innerHTML = `<span class="online">${_t('stt_listening')}</span>`;
  } catch (e) {
    statusEl.innerHTML = '<span class="offline">Micro refuse: ' + e.message + '</span>';
  }
}

// ── Mode 2: Auto-ecoute continue (VAD) ───────────────────────

function stopAutoListen() {
  autoListenActive = false;
  isSpeaking = false;
  autoProcessing = false;
  if (autoProcessor) autoProcessor.disconnect();
  if (autoStream) autoStream.getTracks().forEach(t => t.stop());
  if (autoContext) autoContext.close();
  autoBtn.classList.remove('active', 'waiting', 'hearing', 'transcribing');
  scanner.classList.remove('auto-listening', 'auto-hearing');
  statusEl.innerHTML = `<span class="online">${_t('auto_stopped')}</span>`;
}

async function processAutoSpeech() {
  if (autoPcmChunks.length === 0) return;
  autoProcessing = true;
  autoBtn.classList.remove('hearing');
  autoBtn.classList.add('transcribing');
  scanner.classList.remove('auto-hearing');

  const chunks = autoPcmChunks.slice();
  autoPcmChunks = [];

  try {
    const data = await sendToSTT(chunks, 16000);
    if (await handleSTTResult(data)) {
      await waitForAudioEnd();
    }
  } catch (e) {
    statusEl.innerHTML = `<span class="offline">${_t('stt_error')}</span>`;
  }

  // Reset VAD state cleanly before resuming
  isSpeaking = false;
  silenceStart = 0;
  autoPcmChunks = [];
  autoProcessing = false;
  autoBtn.classList.remove('transcribing');
  if (autoListenActive) {
    autoBtn.classList.add('active', 'waiting');
    scanner.classList.add('auto-listening');
    statusEl.innerHTML = '<span class="online">Auto-ecoute: en attente...</span>';
  }
}

// ── Helper: Wait for audio playback to end ────────────────────
async function waitForAudioEnd() {
  await new Promise(r => setTimeout(r, 500));
  await new Promise(r => {
    const check = setInterval(() => {
      if (!scanner.classList.contains('speaking')) { clearInterval(check); r(); }
    }, 300);
    setTimeout(() => { clearInterval(check); r(); }, 30000);
  });
  await new Promise(r => setTimeout(r, 1500));
}

// ── Mode 3: Wake word detection (KYRONEX) ─────────────────────

let wakeListenActive = false;
let wakeStream = null;
let wakeContext = null;
let wakeProcessor = null;
let wakeAnalyser = null;
let wakePcmChunks = [];
let wakeIsSpeaking = false;
let wakeSilenceStart = 0;
let wakeSpeechStart = 0;
let wakeProcessing = false;
let wakeAwaitingCommand = false;
let wakeCommandTimeout = null;
const WAKE_REGEX = /\bki+t+\b/i;

function detectWakeWord(text) {
  const match = text.match(WAKE_REGEX);
  if (!match) return { found: false, command: '' };
  const afterWake = text.slice(match.index + match[0].length).trim();
  // Strip leading punctuation/filler
  const command = afterWake.replace(/^[,.\s!?:]+/, '').trim();
  return { found: true, command };
}

function stopWakeListen() {
  wakeListenActive = false;
  wakeIsSpeaking = false;
  wakeProcessing = false;
  wakeAwaitingCommand = false;
  if (wakeCommandTimeout) { clearTimeout(wakeCommandTimeout); wakeCommandTimeout = null; }
  if (wakeProcessor) wakeProcessor.disconnect();
  if (wakeStream) wakeStream.getTracks().forEach(t => t.stop());
  if (wakeContext) wakeContext.close();
  wakeBtn.classList.remove('active', 'waiting', 'hearing', 'transcribing', 'wake-triggered');
  scanner.classList.remove('wake-listening', 'wake-hearing', 'wake-triggered');
  statusEl.innerHTML = '<span class="online">Wake word arrete</span>';
}

function resumeWakeListening() {
  wakeIsSpeaking = false;
  wakeSilenceStart = 0;
  wakePcmChunks = [];
  wakeProcessing = false;
  wakeAwaitingCommand = false;
  if (wakeCommandTimeout) { clearTimeout(wakeCommandTimeout); wakeCommandTimeout = null; }
  wakeBtn.classList.remove('hearing', 'transcribing', 'wake-triggered');
  scanner.classList.remove('wake-hearing', 'wake-triggered');
  if (wakeListenActive) {
    wakeBtn.classList.add('active', 'waiting');
    scanner.classList.add('wake-listening');
    statusEl.innerHTML = `<span class="online">${_t('wake_waiting')}</span>`;
  }
}

async function processWakeSpeech() {
  if (wakePcmChunks.length === 0) return;
  wakeProcessing = true;
  wakeBtn.classList.remove('hearing');
  wakeBtn.classList.add('transcribing');
  scanner.classList.remove('wake-hearing');

  const chunks = wakePcmChunks.slice();
  wakePcmChunks = [];

  try {
    const data = await sendToSTT(chunks, 16000);
    const text = (data.text || '').trim();

    if (!text) {
      resumeWakeListening();
      return;
    }

    const langInfo = data.language ? ` · ${data.language.toUpperCase()}` : '';
    _updateLangDetection(data.language || '', text, 'wake-stt');
    statusEl.innerHTML = `<span class="online">STT: ${data.stt_ms}ms${langInfo} — "${text}"</span>`;

    if (wakeAwaitingCommand) {
      // We were waiting for a command after "KYRONEX" alone
      wakeAwaitingCommand = false;
      if (wakeCommandTimeout) { clearTimeout(wakeCommandTimeout); wakeCommandTimeout = null; }
      wakeBtn.classList.remove('transcribing', 'wake-triggered');
      scanner.classList.remove('wake-triggered');
      addMessage(text, 'user');
      sendBtn.disabled = true;
      await streamChat(text, data.language || '');
      await waitForAudioEnd();
      resumeWakeListening();
      return;
    }

    const { found, command } = detectWakeWord(text);

    if (!found) {
      // No wake word — discard
      statusEl.innerHTML = `<span class="online">${_t('wake_no_keyword')}</span>`;
      resumeWakeListening();
      return;
    }

    if (command.length > 0) {
      // "KYRONEX quelle heure est-il" → chat with command
      wakeBtn.classList.remove('transcribing');
      addMessage(command, 'user');
      sendBtn.disabled = true;
      await streamChat(command, data.language || '');
      await waitForAudioEnd();
      resumeWakeListening();
      return;
    }

    // "KYRONEX" alone → triggered state, wait for follow-up command (6s)
    wakeAwaitingCommand = true;
    wakeBtn.classList.remove('transcribing');
    wakeBtn.classList.add('wake-triggered');
    scanner.classList.add('wake-triggered');
    statusEl.innerHTML = `<span class="online">${_t('wake_detected')}</span>`;
    wakeProcessing = false;

    wakeCommandTimeout = setTimeout(() => {
      if (wakeAwaitingCommand) {
        statusEl.innerHTML = `<span class="online">${_t('wake_timeout')}</span>`;
        resumeWakeListening();
      }
    }, 6000);
    return;

  } catch (e) {
    statusEl.innerHTML = `<span class="offline">${_t('stt_error')}</span>`;
  }

  resumeWakeListening();
}

async function toggleWakeListen() {
  if (isRecording) stopRecording();
  if (autoListenActive) stopAutoListen();
  if (wakeListenActive) { stopWakeListen(); return; }

  try {
    statusEl.innerHTML = '<span class="online">Demande micro...</span>';
    wakeStream = await getUserMediaCompat({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true } });

    wakeContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
    const source = wakeContext.createMediaStreamSource(wakeStream);

    wakeAnalyser = wakeContext.createAnalyser();
    wakeAnalyser.fftSize = 2048;
    source.connect(wakeAnalyser);

    wakeProcessor = wakeContext.createScriptProcessor(4096, 1, 1);
    wakePcmChunks = [];
    wakeIsSpeaking = false;
    wakeSilenceStart = 0;
    wakeSpeechStart = 0;

    wakeProcessor.onaudioprocess = (e) => {
      if (!wakeListenActive || (wakeProcessing && !wakeAwaitingCommand)) return;
      const buf = new Float32Array(wakeAnalyser.fftSize);
      wakeAnalyser.getFloatTimeDomainData(buf);
      let sum = 0;
      for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
      const rms = Math.sqrt(sum / buf.length);
      const now = Date.now();

      if (rms > VAD_THRESHOLD) {
        if (!wakeIsSpeaking) {
          wakeIsSpeaking = true;
          wakeSpeechStart = now;
          wakePcmChunks = [];
          wakeBtn.classList.remove('waiting', 'wake-triggered');
          wakeBtn.classList.add('hearing');
          scanner.classList.remove('wake-listening', 'wake-triggered');
          scanner.classList.add('wake-hearing');
          if (!wakeAwaitingCommand) {
            statusEl.innerHTML = `<span class="online">${_t('stt_detected')}</span>`;
          } else {
            statusEl.innerHTML = `<span class="online">${_t('cmd_detected')}</span>`;
          }
        }
        wakeSilenceStart = 0;
        wakePcmChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
      } else if (wakeIsSpeaking) {
        wakePcmChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
        if (!wakeSilenceStart) wakeSilenceStart = now;
        if (now - wakeSilenceStart > SILENCE_DURATION) {
          wakeIsSpeaking = false;
          if (now - wakeSpeechStart > MIN_SPEECH_DURATION) {
            processWakeSpeech();
          } else {
            wakePcmChunks = [];
            wakeBtn.classList.remove('hearing');
            if (wakeAwaitingCommand) {
              wakeBtn.classList.add('wake-triggered');
              scanner.classList.remove('wake-hearing');
              scanner.classList.add('wake-triggered');
            } else {
              wakeBtn.classList.add('waiting');
              scanner.classList.remove('wake-hearing');
              scanner.classList.add('wake-listening');
              statusEl.innerHTML = `<span class="online">${_t('wake_waiting')}</span>`;
            }
          }
        }
      }
    };

    source.connect(wakeProcessor);
    wakeProcessor.connect(wakeContext.destination);

    wakeListenActive = true;
    wakeBtn.classList.add('active', 'waiting');
    scanner.classList.add('wake-listening');
    statusEl.innerHTML = `<span class="online">${_t('wake_waiting')}</span>`;
  } catch (e) {
    statusEl.innerHTML = '<span class="offline">Micro refuse: ' + e.message + '</span>';
  }
}

async function toggleAutoListen() {
  if (isRecording) stopRecording();
  if (wakeListenActive) stopWakeListen();
  if (autoListenActive) { stopAutoListen(); return; }

  try {
    statusEl.innerHTML = '<span class="online">Demande micro...</span>';
    autoStream = await getUserMediaCompat({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true } });

    autoContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
    const source = autoContext.createMediaStreamSource(autoStream);

    autoAnalyser = autoContext.createAnalyser();
    autoAnalyser.fftSize = 2048;
    source.connect(autoAnalyser);

    autoProcessor = autoContext.createScriptProcessor(4096, 1, 1);
    autoPcmChunks = [];
    isSpeaking = false;
    silenceStart = 0;
    speechStart = 0;

    autoProcessor.onaudioprocess = (e) => {
      if (!autoListenActive || autoProcessing) return;
      const buf = new Float32Array(autoAnalyser.fftSize);
      autoAnalyser.getFloatTimeDomainData(buf);
      let sum = 0;
      for (let i = 0; i < buf.length; i++) sum += buf[i] * buf[i];
      const rms = Math.sqrt(sum / buf.length);
      const now = Date.now();

      if (rms > VAD_THRESHOLD) {
        if (!isSpeaking) {
          isSpeaking = true;
          speechStart = now;
          autoPcmChunks = [];
          autoBtn.classList.remove('waiting');
          autoBtn.classList.add('hearing');
          scanner.classList.remove('auto-listening');
          scanner.classList.add('auto-hearing');
          statusEl.innerHTML = `<span class="online">${_t('stt_detected')}</span>`;
        }
        silenceStart = 0;
        autoPcmChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
      } else if (isSpeaking) {
        autoPcmChunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
        if (!silenceStart) silenceStart = now;
        if (now - silenceStart > SILENCE_DURATION) {
          isSpeaking = false;
          if (now - speechStart > MIN_SPEECH_DURATION) {
            processAutoSpeech();
          } else {
            autoPcmChunks = [];
            autoBtn.classList.remove('hearing');
            autoBtn.classList.add('waiting');
            scanner.classList.remove('auto-hearing');
            scanner.classList.add('auto-listening');
            statusEl.innerHTML = '<span class="online">Auto-ecoute: en attente...</span>';
          }
        }
      }
    };

    source.connect(autoProcessor);
    autoProcessor.connect(autoContext.destination);

    autoListenActive = true;
    autoBtn.classList.add('active', 'waiting');
    scanner.classList.add('auto-listening');
    statusEl.innerHTML = '<span class="online">Auto-ecoute: en attente...</span>';
  } catch (e) {
    statusEl.innerHTML = '<span class="offline">Micro refuse: ' + e.message + '</span>';
  }
}

// ── Audio activation button ─────────────────────────────────────
const audioBtn = document.getElementById('audiobtn');
let audioActivated = false;

function activateAudio() {
  const ctx = ensurePlaybackCtx();
  if (ctx.state === 'suspended') ctx.resume();
  // Play silent buffer to unlock AudioContext on mobile
  const buf = ctx.createBuffer(1, 1, ctx.sampleRate);
  const src = ctx.createBufferSource();
  src.buffer = buf;
  src.connect(ctx.destination);
  src.start(0);
  audioActivated = true;
  audioBtn.classList.add('active');
}

// Auto-detect audio state on interactions
function checkAudioState() {
  if (playbackCtx && playbackCtx.state === 'running' && !audioActivated) {
    audioActivated = true;
    audioBtn.classList.add('active');
  }
}
['click', 'touchstart', 'keydown'].forEach(evt =>
  document.addEventListener(evt, checkAudioState, { passive: true })
);

// ── Sons MU-TH-UR 6000 / ALIEN — traitement données (graves + métalliques) ──
const THINKING_SOUNDS = [
  // Impulsions de traitement — graves sawtooth (comme un vieux disque dur)
  {freq:80,  type:'sawtooth',dur:0.18,mod:8,  ff:180,q:3.5},
  {freq:110, type:'sawtooth',dur:0.14,mod:5,  ff:220,q:4.0},
  {freq:95,  type:'sawtooth',dur:0.22,mod:12, ff:160,q:3.0},
  {freq:130, type:'square',  dur:0.12,mod:3,  ff:240,q:5.0},
  {freq:75,  type:'sawtooth',dur:0.20,mod:6,  ff:140,q:4.5},
  {freq:55,  type:'sawtooth',dur:0.35,mod:15, ff:120,q:2.5},
  {freq:65,  type:'sawtooth',dur:0.30,mod:20, ff:100,q:2.0},
  {freq:85,  type:'sawtooth',dur:0.28,mod:10, ff:150,q:3.0},
  // Séquences de traitement intermédiaires
  {freq:180, type:'sawtooth',dur:0.28,mod:4,  ff:300,q:3.0},
  {freq:220, type:'square',  dur:0.16,mod:8,  ff:350,q:6.0},
  {freq:160, type:'sawtooth',dur:0.24,mod:10, ff:260,q:3.5},
  {freq:145, type:'sawtooth',dur:0.20,mod:7,  ff:200,q:4.0},
  // Beeps terminaux MU-TH-UR (affichage données, style Alien 1979)
  {freq:440, type:'square',  dur:0.08,mod:0,  ff:500,q:8.0},
  {freq:880, type:'square',  dur:0.06,mod:0,  ff:1000,q:10},
  {freq:660, type:'square',  dur:0.07,mod:0,  ff:700,q:9.0},
  {freq:330, type:'sawtooth',dur:0.10,mod:0,  ff:400,q:6.0},
  {freq:1046,type:'square',  dur:0.05,mod:0,  ff:1200,q:12},
  {freq:523, type:'square',  dur:0.07,mod:0,  ff:600,q:8.0},
  {freq:784, type:'square',  dur:0.06,mod:0,  ff:900,q:10},
];

let thinkingLoop = null;
let thinkingTimeout = null;
let lastSounds = [];
let currentThinkingOsc = null;

function playThinkingSound() {
  if (!playbackCtx || playbackCtx.state !== 'running') return;
  const ctx = playbackCtx;
  // Pick random sound avoiding last 3
  let idx;
  do { idx = Math.floor(Math.random() * THINKING_SOUNDS.length); }
  while (lastSounds.includes(idx) && THINKING_SOUNDS.length > 3);
  lastSounds.push(idx);
  if (lastSounds.length > 3) lastSounds.shift();

  const s = THINKING_SOUNDS[idx];
  const now = ctx.currentTime;

  // Oscillator
  const osc = ctx.createOscillator();
  osc.type = s.type;
  osc.frequency.setValueAtTime(s.freq, now);
  osc.frequency.linearRampToValueAtTime(s.freq + s.mod * 10, now + s.dur * 0.5);
  osc.frequency.linearRampToValueAtTime(s.freq, now + s.dur);

  // Filtre résonant (Q élevé = caractère métallique MU-TH-UR)
  const filter = ctx.createBiquadFilter();
  filter.type = 'lowpass';
  filter.frequency.value = s.ff;
  filter.Q.value = s.q || 2;

  // Gain envelope (attaque brève, coupure nette — comme un relais électronique)
  const gain = ctx.createGain();
  gain.gain.setValueAtTime(0, now);
  gain.gain.linearRampToValueAtTime(0.10, now + s.dur * 0.08);
  gain.gain.setValueAtTime(0.10, now + s.dur * 0.65);
  gain.gain.linearRampToValueAtTime(0, now + s.dur);

  osc.connect(filter);
  filter.connect(gain);
  gain.connect(ctx.destination);
  osc.start(now);
  osc.stop(now + s.dur);
  currentThinkingOsc = { osc, gain, endTime: now + s.dur };
}

// ── Son de fin de message (acquittement terminal MU-TH-UR) ──────
function playEndOfMessageSound() {
  if (!playbackCtx || playbackCtx.state !== 'running') return;
  const ctx = playbackCtx;
  const now = ctx.currentTime;
  // Séquence: do-mi (deux notes brèves, comme MOTHER qui "valide" sa réponse)
  [[523, 0], [659, 0.12]].forEach(([freq, delay]) => {
    const osc = ctx.createOscillator();
    osc.type = 'square';
    osc.frequency.value = freq;
    const f = ctx.createBiquadFilter();
    f.type = 'lowpass'; f.frequency.value = 800; f.Q.value = 6;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0, now + delay);
    g.gain.linearRampToValueAtTime(0.06, now + delay + 0.01);
    g.gain.linearRampToValueAtTime(0, now + delay + 0.09);
    osc.connect(f); f.connect(g); g.connect(ctx.destination);
    osc.start(now + delay); osc.stop(now + delay + 0.1);
  });
}

function startThinkingLoop() {
  if (thinkingLoop) return;
  lastSounds = [];
  playThinkingSound();
  function scheduleNext() {
    const delay = 600 + Math.random() * 900; // 600-1500ms — plus irrégulier (données asynchrones)
    thinkingLoop = setTimeout(() => {
      playThinkingSound();
      scheduleNext();
    }, delay);
  }
  scheduleNext();
  // Safety: max 30s
  thinkingTimeout = setTimeout(stopThinkingLoop, 30000);
}

function stopThinkingLoop() {
  if (thinkingLoop) { clearTimeout(thinkingLoop); thinkingLoop = null; }
  if (thinkingTimeout) { clearTimeout(thinkingTimeout); thinkingTimeout = null; }
  // Quick fade-out of current sound
  if (currentThinkingOsc && playbackCtx) {
    try {
      const now = playbackCtx.currentTime;
      currentThinkingOsc.gain.gain.cancelScheduledValues(now);
      currentThinkingOsc.gain.gain.setValueAtTime(currentThinkingOsc.gain.gain.value, now);
      currentThinkingOsc.gain.gain.linearRampToValueAtTime(0, now + 0.05);
    } catch(e) {}
    currentThinkingOsc = null;
  }
}

// ── User identity + langue persistante ──────────────────────────
let currentUserName = '';
let _preferredLang = localStorage.getItem('kyronex_lang') || 'fr';

// Sélecteur de langue dans la modal MOTHER
function selectLang(lang) {
  _preferredLang = lang;
  localStorage.setItem('kyronex_lang', lang);
  document.querySelectorAll('.lang-opt').forEach(b => {
    b.classList.toggle('selected', b.dataset.lang === lang);
  });
  _applyUILang(lang);
  console.log('[KYRONEX · LANG] Préférence sélectionnée:', lang);
}
// Initialiser le sélecteur avec la langue sauvegardée
(function _initLangSelector() {
  document.querySelectorAll('.lang-opt').forEach(b => {
    b.classList.toggle('selected', b.dataset.lang === _preferredLang);
  });
})();

function lockUI() {
  input.disabled = true;
  sendBtn.disabled = true;
  input.placeholder = 'Identifiez-vous d\'abord...';
}

function unlockUI(name, lang) {
  currentUserName = name;
  if (lang) {
    _preferredLang = lang;
    localStorage.setItem('kyronex_lang', lang);
    _updateLangDetection(lang, '', 'stored-preference');
  }
  input.disabled = false;
  sendBtn.disabled = false;
  const PLACEHOLDERS = {
    fr: 'Parlez à KITT...', en: 'Speak to KITT...',
    de: 'Sprechen Sie mit KITT...', it: 'Parla con KITT...',
    pt: 'Fale com KITT...', es: 'Hable con KITT...',
    nl: 'Spreek met KITT...',
  };
  input.placeholder = PLACEHOLDERS[lang || _preferredLang] || PLACEHOLDERS.fr;
  input.focus();
  _loadChatHistory();
  _applyUILang(_preferredLang);
  // Message d'accueil avec le prénom
  const greetings = {
    fr: `Bonjour ${name}. Je suis KITT. Comment puis-je vous assister ?`,
    en: `Hello ${name}. I am KITT. How may I assist you?`,
    de: `Hallo ${name}. Ich bin KITT. Wie kann ich Ihnen helfen?`,
    it: `Salve ${name}. Sono KITT. Come posso assisterla?`,
    pt: `Ola ${name}. Sou KITT. Como posso ajuda-lo?`,
    es: `Hola ${name}. Soy KITT. Como puedo asistirle?`,
    nl: `Hallo ${name}. Ik ben KITT. Hoe kan ik u helpen?`,
  };
  addMessage(greetings[_preferredLang] || greetings.fr, 'kitt');
}

async function initUserIdentity() {
  _applyUILang(_preferredLang);
  lockUI();
  try {
    const res = await fetch('/api/whoami');
    const data = await res.json();
    if (data.name) {
      localStorage.setItem('kyronex_username', data.name);
      if (data.lang) localStorage.setItem('kyronex_lang', data.lang);
      _preferredLang = data.lang || localStorage.getItem('kyronex_lang') || 'fr';
      unlockUI(data.name, _preferredLang);
      _startHeartbeat();
      return;
    }
  } catch(e) {}

  const stored = localStorage.getItem('kyronex_username');
  const storedLang = localStorage.getItem('kyronex_lang') || 'fr';
  if (stored) {
    try {
      await fetch('/api/set-name', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ name: stored, lang: storedLang })
      });
      _preferredLang = storedLang;
      unlockUI(stored, storedLang);
      _startHeartbeat();
      return;
    } catch(e) {}
  }

  // Première fois : afficher la modal MOTHER
  document.getElementById('nameOverlay').classList.add('visible');
  document.getElementById('nameInput').focus();
}

async function submitName() {
  const name = document.getElementById('nameInput').value.trim();
  if (!name) return;
  localStorage.setItem('kyronex_username', name);
  localStorage.setItem('kyronex_lang', _preferredLang);
  try {
    await fetch('/api/set-name', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ name, lang: _preferredLang })
    });
  } catch(e) {}
  document.getElementById('nameOverlay').classList.remove('visible');
  unlockUI(name, _preferredLang);
  _startHeartbeat();
}

// ── Heartbeat — maintient la session active (ping toutes les 30s) ──
let _heartbeatInterval = null;
function _startHeartbeat() {
  if (_heartbeatInterval) return;
  const _doPing = () => {
    fetch('/api/ping', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ session_id: sessionId, name: currentUserName })
    }).then(r => r.json()).then(d => {
      if (d.active !== undefined) {
        const el = document.getElementById('cp-current');
        if (el) el.textContent = d.active;
      }
    }).catch(() => {});
  };
  _doPing();
  _heartbeatInterval = setInterval(_doPing, 30000);
}

// ── Stats connexions (panel gauche) ─────────────────────────────
async function _refreshStats() {
  try {
    const res = await fetch('/api/stats');
    const d = await res.json();
    const c24 = document.getElementById('cp-24h');
    const c7d = document.getElementById('cp-7d');
    const cur = document.getElementById('cp-current');
    const sess = document.getElementById('cp-sessions');
    if (c24) c24.textContent = d.last_24h;
    if (c7d) c7d.textContent = d.last_7d;
    if (cur) cur.textContent = d.current;
    const msOnline = document.getElementById('ms-online');
    if (msOnline && d.current !== undefined) msOnline.textContent = d.current;
    const mpOnline = document.getElementById('mp-online-count');
    if (mpOnline && d.current !== undefined) mpOnline.textContent = d.current;
    if (sess) {
      sess.innerHTML = (d.active_sessions || []).slice(0, 5).map(s =>
        `<div class="cp-ip">${s.ip} <span class="cp-name">${s.name} [${(s.lang||'?').toUpperCase()}]</span></div>`
      ).join('');
    }
  } catch(e) {}
}
_refreshStats();
setInterval(_refreshStats, 20000);

async function _refreshMemory() {
  try {
    const res = await fetch('/api/memory');
    const d   = await res.json();
    const el  = document.getElementById('mp-memory-list');
    if (!el || !d.facts) return;
    const recent = (d.facts || []).slice(-5).reverse();
    el.innerHTML = recent.map(f =>
      `<div class="mp-mem-item">${f.fact.slice(0,55)}${f.fact.length>55?'&hellip;':''}<br>
       <span class="mp-mem-user">${(f.user||'?').toUpperCase()}</span></div>`
    ).join('') || '<div class="mp-mem-user">AUCUN FAIT</div>';
  } catch(e) {}
}
_refreshMemory();
setInterval(_refreshMemory, 60000);

// nameInput est déclaré après ce script — on écoute le clavier via délégation
document.addEventListener('keydown', e => {
  if (e.key === 'Enter' && e.target.id === 'nameInput') submitName();
});

async function resetChat() {
  if (!confirm('Effacer l\'historique KITT ?')) return;
  try {
    await fetch('/api/reset', { method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ session_id: sessionId })
    });
  } catch(e) {}
  chat.querySelectorAll('.message:not(.proactive)').forEach(m => m.remove());
  localStorage.removeItem(CHAT_HISTORY_KEY);
  statusEl.innerHTML = `<span class="online">${_t('history_cleared')}</span>`;
  setTimeout(() => checkHealth(), 2000);
}

async function checkHealth() {
  const msHealth = document.getElementById('ms-health');
  try {
    const res = await fetch('/api/health');
    const data = await res.json();
    if (data.llm_server) {
      statusEl.innerHTML = `<span class="online">${_t('status_online')}</span>`;
      if (msHealth) { msHealth.textContent = _t('ms_online'); msHealth.className = 'online'; }
    } else {
      statusEl.innerHTML = `<span class="offline">${_t('status_llm_off')}</span>`;
      if (msHealth) { msHealth.textContent = _t('ms_llm_off'); msHealth.className = 'offline'; }
    }
  } catch {
    statusEl.innerHTML = `<span class="offline">${_t('status_offline')}</span>`;
    if (msHealth) { msHealth.textContent = _t('ms_offline'); msHealth.className = 'offline'; }
  }
}

checkHealth();
setInterval(checkHealth, 10000);
initUserIdentity();
_drawVoiceboxIdle();

// ── Fix mobile : ajustement hauteur quand clavier virtuel s'ouvre ──
if (window.visualViewport) {
  const _onVV = () => {
    document.body.style.height = window.visualViewport.height + 'px';
    requestAnimationFrame(() => { chat.scrollTop = chat.scrollHeight; });
  };
  window.visualViewport.addEventListener('resize', _onVV);
  window.visualViewport.addEventListener('scroll', _onVV);
}

// ── KITT Proactif — WebSocket pour messages spontanés ──────────
let proactiveWs = null;

function connectProactive() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  proactiveWs = new WebSocket(`${proto}//${location.host}/api/proactive/ws`);

  proactiveWs.onmessage = (e) => {
    try {
      const data = JSON.parse(e.data);

      if (data.type === 'vigilance_alert' && data.message) {
        // Alerte vigilance — style rouge + flash
        const div = document.createElement('div');
        div.className = 'message kitt vigilance-alert';
        div.innerHTML = data.message;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        _playVigilanceSound();
        if (data.audio) playAudio(data.audio);
        return;
      }

      if (data.type === 'proactive' && data.message) {
        // Afficher le message proactif dans le chat
        const div = document.createElement('div');
        div.className = 'message kitt proactive';
        div.innerHTML = data.message;
        chat.appendChild(div);
        chat.scrollTop = chat.scrollHeight;
        if (data.audio) playAudio(data.audio);
      }
    } catch (err) {
      console.error('Proactive WS error:', err);
    }
  };

  proactiveWs.onclose = () => {
    // Reconnexion automatique après 10s
    setTimeout(connectProactive, 10000);
  };

  proactiveWs.onerror = () => {
    proactiveWs.close();
  };
}

// ── Mode Vigilance ─────────────────────────────────────────────
let _vigilanceActive = false;
const vigBtn = document.getElementById('vigbtn');

function _playVigilanceSound() {
  try {
    const ctx2 = new (window.AudioContext || window.webkitAudioContext)();
    [880, 660, 880, 440].forEach((freq, i) => {
      const t = ctx2.currentTime + i * 0.18;
      const osc = ctx2.createOscillator();
      const g = ctx2.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(0.12, t + 0.02);
      g.gain.linearRampToValueAtTime(0, t + 0.14);
      osc.connect(g); g.connect(ctx2.destination);
      osc.start(t); osc.stop(t + 0.15);
    });
    setTimeout(() => ctx2.close(), 1200);
  } catch(e) {}
}

async function toggleVigilance() {
  _vigilanceActive = !_vigilanceActive;
  vigBtn.classList.toggle('active', _vigilanceActive);
  try {
    await fetch('/api/vigilance', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({ enabled: _vigilanceActive })
    });
  } catch(e) {
    console.error('[VIGILANCE] Erreur toggle:', e);
    _vigilanceActive = !_vigilanceActive;
    vigBtn.classList.toggle('active', _vigilanceActive);
  }
}

// ── Orbe énergétique 3D — arrière-plan réactif ────────────────
(function() {
  const canvas = document.getElementById('orb');
  const ctx = canvas.getContext('2d');

  // Pré-allouer le buffer fréquences (évite GC chaque frame)
  const freqBuf = new Uint8Array(64);

  // Résolution : suivre le viewport
  function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resize();
  window.addEventListener('resize', resize);

  // ── Distribution de Fibonacci sur la sphère ──
  const N = window.innerWidth <= 600 ? 80 : 130;
  const pts = [];
  const golden = Math.PI * (1 + Math.sqrt(5));
  for (let i = 0; i < N; i++) {
    const theta = Math.acos(1 - 2 * (i + 0.5) / N);
    const phi   = golden * i;
    pts.push([
      Math.sin(theta) * Math.cos(phi),
      Math.sin(theta) * Math.sin(phi),
      Math.cos(theta)
    ]);
  }

  let ax = 0, ay = 0, t = 0;
  const proj = new Array(N); // réutilisé chaque frame

  function draw() {
    requestAnimationFrame(draw);

    const W = canvas.width, H = canvas.height;
    const cx = W * 0.5, cy = H * 0.5;
    const speaking = scanner.classList.contains('speaking');

    // ── Énergie audio ──
    let energy = 0;
    let hasAudio = false;
    if (voiceboxAnalyser && speaking) {
      voiceboxAnalyser.getByteFrequencyData(freqBuf);
      let sum = 0;
      for (let i = 0; i < freqBuf.length; i++) sum += freqBuf[i];
      energy = sum / (freqBuf.length * 255);
      hasAudio = true;
    }

    t += 0.016;

    // ── Traîne sur canvas transparent (destination-out) ──
    // Efface progressivement le canvas sans fond opaque
    ctx.globalCompositeOperation = 'destination-out';
    ctx.globalAlpha = speaking ? 0.18 : 0.10;
    ctx.fillRect(0, 0, W, H);
    ctx.globalCompositeOperation = 'source-over';
    ctx.globalAlpha = 1;

    // ── Vitesse de rotation ──
    const speed = speaking ? 1 + energy * 3.5 : 0.55;
    ay += 0.006 * speed;
    ax += 0.0022 * speed;
    const cay = Math.cos(ay), say = Math.sin(ay);
    const cax = Math.cos(ax), sax = Math.sin(ax);

    // ── Rayon + pulsation ──
    const baseR    = Math.min(W, H) * 0.21;
    const idlePulse  = 1 + 0.045 * Math.sin(t * 1.1);
    const speakPulse = 1 + energy * 0.48;
    const R = baseR * (speaking ? speakPulse : idlePulse);

    // ── Projeter les N points ──
    for (let i = 0; i < N; i++) {
      let [px, py, pz] = pts[i];

      if (hasAudio) {
        // Distorsion par fréquence audio
        const fi = Math.floor((i / N) * freqBuf.length * 0.7);
        const fv = freqBuf[fi] / 255;
        const d  = 1 + fv * 0.40;
        px *= d; py *= d; pz *= d;
      } else {
        // Déformation organique idle
        const n = 1 + 0.028 * Math.sin(t * 0.75 + i * 0.9);
        px *= n; py *= n; pz *= n;
      }

      // Rotation Y
      const x1 = px * cay + pz * say;
      const z1 = -px * say + pz * cay;
      // Rotation X
      const y2 = py * cax - z1 * sax;
      const z2 = py * sax + z1 * cax;

      // Projection perspective simple
      const fov  = 2.8;
      const s    = fov / (fov + z2);
      const sx   = cx + x1 * R * s;
      const sy   = cy + y2 * R * s;
      const depth = (z2 + 1.5) / 3.0; // 0..1

      proj[i] = { sx, sy, depth, z: z2, i };
    }

    // ── Trier back-to-front ──
    proj.sort((a, b) => a.z - b.z);

    // ── Halo central ──
    const haloR = R * 0.75;
    const haloA = speaking
      ? 0.18 + energy * 0.22
      : 0.10 + 0.04 * Math.sin(t * 0.85);
    const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, haloR);
    grd.addColorStop(0,    `rgba(255,80,0,${haloA})`);
    grd.addColorStop(0.4,  `rgba(220,20,0,${(haloA * 0.5).toFixed(3)})`);
    grd.addColorStop(0.75, `rgba(160,0,0,${(haloA * 0.15).toFixed(3)})`);
    grd.addColorStop(1,    'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(cx, cy, haloR, 0, Math.PI * 2);
    ctx.fill();

    // ── Lignes de connexion (mode speaking uniquement) ──
    if (speaking && energy > 0.07) {
      ctx.shadowBlur = 0;
      const maxD  = 42 + energy * 38;
      const maxD2 = maxD * maxD;
      const front = [];
      for (let i = 0; i < N; i++) {
        if (proj[i].depth > 0.38) front.push(proj[i]);
      }
      const lim = Math.min(front.length, 50);
      for (let i = 0; i < lim; i++) {
        for (let j = i + 1; j < lim; j++) {
          const dx = front[i].sx - front[j].sx;
          const dy = front[i].sy - front[j].sy;
          const d2 = dx * dx + dy * dy;
          if (d2 < maxD2) {
            const la = (1 - Math.sqrt(d2) / maxD) * energy * 0.55;
            ctx.strokeStyle = `rgba(255,75,0,${la.toFixed(3)})`;
            ctx.lineWidth = 0.55;
            ctx.beginPath();
            ctx.moveTo(front[i].sx, front[i].sy);
            ctx.lineTo(front[j].sx, front[j].sy);
            ctx.stroke();
          }
        }
      }
    }

    // ── Points de la sphère ──
    ctx.shadowColor = '#ff3300';
    ctx.shadowBlur  = speaking ? 18 + energy * 20 : 8;
    for (let k = 0; k < N; k++) {
      const p = proj[k];
      if (p.depth < 0.05) continue;
      const dotR  = speaking ? 2.5 + p.depth * 5.0 : 1.8 + p.depth * 3.0;
      const alpha = speaking
        ? 0.55 + p.depth * 0.45
        : 0.35 + p.depth * 0.45;
      const em = window._kittOrbEmotion || { r: 255, g: 0, b: 0 };
      const rr = Math.min(255, em.r + Math.floor(p.depth * 55));
      const gg = speaking ? Math.min(255, em.g + Math.floor(energy * 90)) : em.g;
      ctx.fillStyle = `rgba(${rr},${gg},${em.b},${alpha.toFixed(3)})`;
      ctx.beginPath();
      ctx.arc(p.sx, p.sy, dotR, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.shadowBlur = 0;
  }

  draw();
})();

// ── Language detection — logging console + historique ─────────
const _SUPPORTED_LANGS = ['fr', 'en', 'de', 'it', 'pt', 'es', 'nl'];
const _langHistory = [];

function _logLangDetection(lang, source, text) {
  console.group('%c[KYRONEX · LANG] Détection langue', 'color:#00cc44;font-weight:bold');
  console.log('Langue détectée :', lang ? lang.toUpperCase() : 'INCONNUE');
  console.log('Source :', source);
  console.log('Texte :', (text || '').slice(0, 80));
  console.log('Langue précédente :', _lastDetectedLang || 'aucune');
  console.log('Supportée :', _SUPPORTED_LANGS.includes(lang));
  if (_langHistory.length > 0) {
    console.table(_langHistory.slice(-5).map(e => ({
      heure: e.time, langue: e.lang, source: e.src, acceptee: e.ok, debut: e.text
    })));
  }
  console.groupEnd();
}

function _updateLangDetection(lang, text, source) {
  const ok = !lang || _SUPPORTED_LANGS.includes(lang);
  _langHistory.push({ time: new Date().toLocaleTimeString(), lang: lang || 'auto', src: source, ok, text: (text || '').slice(0, 40) });
  if (_langHistory.length > 10) _langHistory.shift();
  _logLangDetection(lang, source, text);
  if (ok && lang) {
    _lastDetectedLang = lang;
    const badge = document.getElementById('lang-badge');
    if (badge) { badge.textContent = lang.toUpperCase(); badge.classList.add('visible'); }
    const mpLang = document.getElementById('mp-lang');
    if (mpLang) mpLang.textContent = lang.toUpperCase();
    // Mettre à jour le placeholder de l'input
    const PLACEHOLDERS = {
      fr: 'Parlez à KITT...', en: 'Speak to KITT...',
      de: 'Sprechen Sie mit KITT...', it: 'Parla con KITT...',
      pt: 'Fale com KITT...', es: 'Hable con KITT...',
      nl: 'Spreek met KITT...',
    };
    const displayLang = _preferredLang || lang;
    if (input && !input.disabled) input.placeholder = PLACEHOLDERS[displayLang] || PLACEHOLDERS.fr;
  } else if (!ok) {
    console.warn('[KYRONEX · LANG] Langue non supportée: "' + lang + '" — ignorée');
  }
}

// ── Gestion clavier mobile (visualViewport API) ──────────────────
(function _initMobileKeyboard() {
  if (!window.visualViewport) return;
  const chat = document.getElementById('chat');
  let _kbOpen = false;

  function _onVVResize() {
    const vv = window.visualViewport;
    const kbHeight = (window.innerHeight - vv.height) - vv.offsetTop;
    const kbOpen = kbHeight > 120;
    if (kbOpen === _kbOpen) return;
    _kbOpen = kbOpen;
    document.body.classList.toggle('keyboard-open', kbOpen);
    if (kbOpen) {
      // Redimensionner le body au viewport visuel
      document.body.style.height = vv.height + 'px';
      document.body.style.top = vv.offsetTop + 'px';
      // Scroll chat en bas pour voir le dernier message
      setTimeout(() => { if (chat) chat.scrollTop = chat.scrollHeight; }, 150);
    } else {
      document.body.style.height = '';
      document.body.style.top = '';
    }
  }

  window.visualViewport.addEventListener('resize', _onVVResize);
  window.visualViewport.addEventListener('scroll', _onVVResize);

  // Focus/blur sur l'input texte pour forcer le scroll
  const inp = document.getElementById('input');
  if (inp) {
    inp.addEventListener('focus', () => {
      setTimeout(() => { if (chat) chat.scrollTop = chat.scrollHeight; }, 350);
    });
  }
})();

// ── MOTHER panel — mise à jour toutes les secondes ─────────────
(function _initMotherPanel() {
  const sesEl = document.getElementById('mp-session');
  if (sesEl) sesEl.textContent = sessionId.slice(-6).toUpperCase();
  setInterval(() => {
    const timeEl = document.getElementById('mp-time');
    if (timeEl) timeEl.textContent = new Date().toLocaleTimeString('fr-BE', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    const stEl = document.getElementById('mp-status');
    if (stEl) {
      const txt = statusEl.textContent || '';
      const online = txt.includes('LIGNE') || txt.includes('STT') || txt.includes('ms');
      stEl.textContent = online ? 'READY' : 'WAIT';
      stEl.style.color = online ? '#00ff55' : '#aa4400';
    }
  }, 1000);
})();

// ── Ambient sound (MU-TH-UR 6000 — drone + bruit machine) ─────
let ambientActive = false;
let ambientGain = null;
let _ambientNodes = [];

function _createAmbient() {
  const ctx = ensurePlaybackCtx();
  ambientGain = ctx.createGain();
  ambientGain.gain.setValueAtTime(0, ctx.currentTime);
  ambientGain.connect(ctx.destination);

  // Drone 60 Hz (électrique)
  const d1 = ctx.createOscillator(); d1.type = 'sine'; d1.frequency.value = 60;
  const g1 = ctx.createGain(); g1.gain.value = 0.32;
  d1.connect(g1); g1.connect(ambientGain); d1.start();

  // Harmonique 120 Hz
  const d2 = ctx.createOscillator(); d2.type = 'triangle'; d2.frequency.value = 120;
  const g2 = ctx.createGain(); g2.gain.value = 0.14;
  d2.connect(g2); g2.connect(ambientGain); d2.start();

  // Bruit blanc filtré (salle informatique)
  const noiseLen = ctx.sampleRate * 4;
  const noiseBuf = ctx.createBuffer(1, noiseLen, ctx.sampleRate);
  const nd = noiseBuf.getChannelData(0);
  for (let i = 0; i < noiseLen; i++) nd[i] = (Math.random() * 2 - 1) * 0.22;
  const noiseSrc = ctx.createBufferSource();
  noiseSrc.buffer = noiseBuf; noiseSrc.loop = true;
  const noiseFilter = ctx.createBiquadFilter();
  noiseFilter.type = 'bandpass'; noiseFilter.frequency.value = 380; noiseFilter.Q.value = 0.9;
  const gn = ctx.createGain(); gn.gain.value = 0.11;
  noiseSrc.connect(noiseFilter); noiseFilter.connect(gn); gn.connect(ambientGain); noiseSrc.start();

  // LFO lent pour variation organique
  const lfo = ctx.createOscillator(); lfo.type = 'sine'; lfo.frequency.value = 0.07;
  const lfoG = ctx.createGain(); lfoG.gain.value = 0.007;
  lfo.connect(lfoG); lfoG.connect(ambientGain.gain); lfo.start();

  _ambientNodes = [d1, d2, noiseSrc, lfo];
}

function toggleAmbient() {
  const btn = document.getElementById('ambientbtn');
  const ctx = ensurePlaybackCtx();
  if (!ambientGain) _createAmbient();
  if (!ambientActive) {
    ambientActive = true;
    btn.classList.add('active');
    ambientGain.gain.cancelScheduledValues(ctx.currentTime);
    ambientGain.gain.setValueAtTime(ambientGain.gain.value, ctx.currentTime);
    ambientGain.gain.linearRampToValueAtTime(0.022, ctx.currentTime + 2.5);
    console.log('[KYRONEX · AMB] Sons d\'ambiance activés');
  } else {
    ambientActive = false;
    btn.classList.remove('active');
    ambientGain.gain.cancelScheduledValues(ctx.currentTime);
    ambientGain.gain.setValueAtTime(ambientGain.gain.value, ctx.currentTime);
    ambientGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.5);
    console.log('[KYRONEX · AMB] Sons d\'ambiance désactivés');
  }
}

// ── Émotions visuelles KITT ──────────────────────────────────────
const EMOTION_COLORS = {
  normal:    { r:255, g:0,   b:0,   scanColor:'255,0,0',    glowHex:'#ff0000' },
  excited:   { r:255, g:136, b:0,   scanColor:'255,136,0',  glowHex:'#ff8800' },
  worried:   { r:68,  g:136, b:255, scanColor:'68,136,255', glowHex:'#4488ff' },
  sad:       { r:136, g:136, b:136, scanColor:'136,136,136',glowHex:'#888888' },
  confident: { r:170, g:68,  b:255, scanColor:'170,68,255', glowHex:'#aa44ff' },
};

// ── Traductions UI multilingues ──────────────────────────────────
const _UI_STRINGS = {
  fr: {
    modal_title: 'IDENTIFICATION',
    modal_sub: "PROTOCOLE D'ACCES — SYSTEME KYRONEX",
    modal_prompt: 'ENTREZ VOTRE IDENTIFIANT OPERATEUR :',
    modal_placeholder: 'Votre prenom',
    modal_btn: 'INITIER CONNEXION',
    status_online: 'KITT EN LIGNE',
    status_llm_off: 'LLM HORS LIGNE — Demarrez llama-server',
    status_offline: 'SERVEUR HORS LIGNE',
    ms_online: 'EN LIGNE',
    ms_llm_off: 'LLM OFF',
    ms_offline: 'OFFLINE',
    stt_listening: 'Ecoute en cours...',
    stt_detected: 'Parole detectee...',
    stt_nothing: 'Rien entendu — parlez plus fort',
    stt_error: 'Erreur STT',
    auto_stopped: 'Auto-ecoute arretee',
    wake_waiting: 'Wake: en attente de "KITT"...',
    wake_detected: 'KITT detecte — parlez maintenant...',
    wake_no_keyword: 'Wake: pas de mot-cle detecte',
    wake_stopped: 'Wake word arrete',
    wake_timeout: 'Timeout — retour en ecoute',
    history_cleared: 'Historique efface',
    camera_capture: 'Capture camera...',
    cmd_detected: 'Commande detectee...',
    enhance_active: 'OPTIMISATION ACTIVE',
  },
  en: {
    modal_title: 'IDENTIFICATION',
    modal_sub: 'ACCESS PROTOCOL — KYRONEX SYSTEM',
    modal_prompt: 'ENTER YOUR OPERATOR IDENTIFIER:',
    modal_placeholder: 'Your first name',
    modal_btn: 'INITIATE CONNECTION',
    status_online: 'KITT ONLINE',
    status_llm_off: 'LLM OFFLINE — Start llama-server',
    status_offline: 'SERVER OFFLINE',
    ms_online: 'ONLINE',
    ms_llm_off: 'LLM OFF',
    ms_offline: 'OFFLINE',
    stt_listening: 'Listening...',
    stt_detected: 'Speech detected...',
    stt_nothing: 'Nothing heard — speak louder',
    stt_error: 'STT Error',
    auto_stopped: 'Auto-listen stopped',
    wake_waiting: 'Wake: waiting for "KITT"...',
    wake_detected: 'KITT detected — speak now...',
    wake_no_keyword: 'Wake: no keyword detected',
    wake_stopped: 'Wake word stopped',
    wake_timeout: 'Timeout — resuming listen',
    history_cleared: 'History cleared',
    camera_capture: 'Camera capture...',
    cmd_detected: 'Command detected...',
    enhance_active: 'OPTIMIZATION ACTIVE',
  },
  de: {
    modal_title: 'IDENTIFIKATION',
    modal_sub: 'ZUGANGSPROTOKOLL — KYRONEX SYSTEM',
    modal_prompt: 'GEBEN SIE IHRE BEDIENER-ID EIN:',
    modal_placeholder: 'Ihr Vorname',
    modal_btn: 'VERBINDUNG HERSTELLEN',
    status_online: 'KITT ONLINE',
    status_llm_off: 'LLM OFFLINE — llama-server starten',
    status_offline: 'SERVER OFFLINE',
    ms_online: 'ONLINE',
    ms_llm_off: 'LLM AUS',
    ms_offline: 'OFFLINE',
    stt_listening: 'Zuhoren...',
    stt_detected: 'Sprache erkannt...',
    stt_nothing: 'Nichts gehort — lauter sprechen',
    stt_error: 'STT-Fehler',
    auto_stopped: 'Auto-Zuhoren gestoppt',
    wake_waiting: 'Wake: warte auf "KITT"...',
    wake_detected: 'KITT erkannt — sprechen Sie jetzt...',
    wake_no_keyword: 'Wake: kein Schlusselwort erkannt',
    wake_stopped: 'Wake-Wort gestoppt',
    wake_timeout: 'Timeout — zuruck zum Zuhoren',
    history_cleared: 'Verlauf geloscht',
    camera_capture: 'Kamera-Aufnahme...',
    cmd_detected: 'Befehl erkannt...',
    enhance_active: 'OPTIMIERUNG AKTIV',
  },
  it: {
    modal_title: 'IDENTIFICAZIONE',
    modal_sub: 'PROTOCOLLO ACCESSO — SISTEMA KYRONEX',
    modal_prompt: 'INSERISCI IL TUO IDENTIFICATIVO OPERATORE:',
    modal_placeholder: 'Il tuo nome',
    modal_btn: 'AVVIA CONNESSIONE',
    status_online: 'KITT IN LINEA',
    status_llm_off: 'LLM OFFLINE — Avviare llama-server',
    status_offline: 'SERVER OFFLINE',
    ms_online: 'ONLINE',
    ms_llm_off: 'LLM OFF',
    ms_offline: 'OFFLINE',
    stt_listening: 'Ascolto in corso...',
    stt_detected: 'Voce rilevata...',
    stt_nothing: 'Niente sentito — parli piu forte',
    stt_error: 'Errore STT',
    auto_stopped: 'Ascolto automatico fermato',
    wake_waiting: 'Wake: in attesa di "KITT"...',
    wake_detected: 'KITT rilevato — parli ora...',
    wake_no_keyword: 'Wake: nessuna parola chiave rilevata',
    wake_stopped: 'Wake word fermato',
    wake_timeout: 'Timeout — ritorno in ascolto',
    history_cleared: 'Cronologia cancellata',
    camera_capture: 'Acquisizione fotocamera...',
    cmd_detected: 'Comando rilevato...',
    enhance_active: 'OTTIMIZZAZIONE ATTIVA',
  },
  pt: {
    modal_title: 'IDENTIFICACAO',
    modal_sub: 'PROTOCOLO DE ACESSO — SISTEMA KYRONEX',
    modal_prompt: 'INSIRA O SEU IDENTIFICADOR DE OPERADOR:',
    modal_placeholder: 'O seu nome',
    modal_btn: 'INICIAR CONEXAO',
    status_online: 'KITT ONLINE',
    status_llm_off: 'LLM OFFLINE — Iniciar llama-server',
    status_offline: 'SERVIDOR OFFLINE',
    ms_online: 'ONLINE',
    ms_llm_off: 'LLM OFF',
    ms_offline: 'OFFLINE',
    stt_listening: 'A ouvir...',
    stt_detected: 'Voz detectada...',
    stt_nothing: 'Nada ouvido — fale mais alto',
    stt_error: 'Erro STT',
    auto_stopped: 'Escuta automatica parada',
    wake_waiting: 'Wake: a aguardar "KITT"...',
    wake_detected: 'KITT detectado — fale agora...',
    wake_no_keyword: 'Wake: nenhuma palavra-chave detectada',
    wake_stopped: 'Wake word parado',
    wake_timeout: 'Timeout — regressar a escuta',
    history_cleared: 'Historico limpo',
    camera_capture: 'Captura de camara...',
    cmd_detected: 'Comando detectado...',
    enhance_active: 'OTIMIZACAO ATIVA',
  },
  es: {
    modal_title: 'IDENTIFICACION',
    modal_sub: 'PROTOCOLO DE ACCESO — SISTEMA KYRONEX',
    modal_prompt: 'INTRODUZCA SU IDENTIFICADOR DE OPERADOR:',
    modal_placeholder: 'Su nombre',
    modal_btn: 'INICIAR CONEXION',
    status_online: 'KITT EN LINEA',
    status_llm_off: 'LLM SIN CONEXION — Iniciar llama-server',
    status_offline: 'SERVIDOR SIN CONEXION',
    ms_online: 'EN LINEA',
    ms_llm_off: 'LLM OFF',
    ms_offline: 'OFFLINE',
    stt_listening: 'Escuchando...',
    stt_detected: 'Voz detectada...',
    stt_nothing: 'Nada oido — hable mas fuerte',
    stt_error: 'Error STT',
    auto_stopped: 'Escucha automatica detenida',
    wake_waiting: 'Wake: esperando "KITT"...',
    wake_detected: 'KITT detectado — hable ahora...',
    wake_no_keyword: 'Wake: ninguna palabra clave detectada',
    wake_stopped: 'Wake word detenido',
    wake_timeout: 'Tiempo agotado — volviendo a escuchar',
    history_cleared: 'Historial borrado',
    camera_capture: 'Captura de camara...',
    cmd_detected: 'Comando detectado...',
    enhance_active: 'OPTIMIZACION ACTIVA',
  },
  nl: {
    modal_title: 'IDENTIFICATIE',
    modal_sub: 'TOEGANGSPROTOCOL — KYRONEX SYSTEEM',
    modal_prompt: 'VOER UW OPERATOR-IDENTIFICATIE IN:',
    modal_placeholder: 'Uw voornaam',
    modal_btn: 'VERBINDING STARTEN',
    status_online: 'KITT ONLINE',
    status_llm_off: 'LLM OFFLINE — Start llama-server',
    status_offline: 'SERVER OFFLINE',
    ms_online: 'ONLINE',
    ms_llm_off: 'LLM UIT',
    ms_offline: 'OFFLINE',
    stt_listening: 'Luisteren...',
    stt_detected: 'Spraak gedetecteerd...',
    stt_nothing: 'Niets gehoord — spreek luider',
    stt_error: 'STT-fout',
    auto_stopped: 'Auto-luisteren gestopt',
    wake_waiting: 'Wake: wachten op "KITT"...',
    wake_detected: 'KITT gedetecteerd — spreek nu...',
    wake_no_keyword: 'Wake: geen wachtwoord gedetecteerd',
    wake_stopped: 'Wake word gestopt',
    wake_timeout: 'Timeout — terug naar luisteren',
    history_cleared: 'Geschiedenis gewist',
    camera_capture: 'Camera-opname...',
    cmd_detected: 'Opdracht gedetecteerd...',
    enhance_active: 'OPTIMALISATIE ACTIEF',
  },
};

function _t(key) {
  try {
    const lang = _preferredLang || 'fr';
    return (_UI_STRINGS[lang] || _UI_STRINGS.fr)[key] || (_UI_STRINGS.fr)[key] || key;
  } catch(e) { return key; }
}

function _applyUILang(lang) {
  const s = _UI_STRINGS[lang] || _UI_STRINGS.fr;
  const mbTitle  = document.getElementById('mb-title');
  const mbSub    = document.getElementById('mb-sub');
  const mbPrompt = document.getElementById('mb-prompt');
  const mbInput  = document.getElementById('nameInput');
  const mbBtn    = document.getElementById('mb-btn');
  if (mbTitle)  mbTitle.textContent  = s.modal_title;
  if (mbSub)    mbSub.textContent    = s.modal_sub;
  if (mbPrompt) mbPrompt.textContent = s.modal_prompt;
  if (mbInput)  mbInput.placeholder  = s.modal_placeholder;
  if (mbBtn)    mbBtn.textContent    = s.modal_btn;
  const PLACEHOLDERS = {
    fr: 'Parlez a KITT...', en: 'Speak to KITT...',
    de: 'Sprechen Sie mit KITT...', it: 'Parla con KITT...',
    pt: 'Fale com KITT...', es: 'Hable con KITT...', nl: 'Spreek met KITT...',
  };
  if (input && !input.disabled) input.placeholder = PLACEHOLDERS[lang] || PLACEHOLDERS.fr;
}

let _emotionTimeout = null;

function applyEmotion(emotion) {
  if (!EMOTION_COLORS[emotion]) return;
  const cfg = EMOTION_COLORS[emotion];

  // Sphère CSS
  const core = document.querySelector('.s-core');
  if (core) {
    core.style.background = `radial-gradient(circle at 40% 35%,${cfg.glowHex}88,${cfg.glowHex})`;
    core.style.boxShadow  = `0 0 22px ${cfg.glowHex},0 0 55px ${cfg.glowHex}88`;
    core.style.transition = 'background 0.8s ease,box-shadow 0.8s ease';
  }
  document.querySelectorAll('.s-mer,.s-par').forEach(el => {
    el.style.borderColor = `rgba(${cfg.r},${cfg.g},${cfg.b},0.60)`;
    el.style.transition  = 'border-color 0.8s ease';
  });

  // Jarvis SVG teinte
  const jarvis = document.getElementById('jarvis-svg');
  const FILTERS = {
    normal:    '',
    excited:   'hue-rotate(30deg) saturate(1.4)',
    worried:   'hue-rotate(-170deg) saturate(1.2)',
    sad:       'grayscale(0.8) brightness(0.7)',
    confident: 'hue-rotate(270deg) saturate(1.5)'
  };
  if (jarvis) {
    jarvis.dataset.emotionFilter = FILTERS[emotion] || '';
    jarvis.style.transition = 'filter 1.2s ease';
  }

  // Variables globales pour scanner IIFE et orbe IIFE
  window._kittEmotionScanColor = cfg.scanColor;
  window._kittOrbEmotion = { r: cfg.r, g: cfg.g, b: cfg.b };

  if (_emotionTimeout) clearTimeout(_emotionTimeout);
  _emotionTimeout = setTimeout(() => applyEmotion('normal'), 30000);
}

// ── Scanner KI2000 — Animation rAF ──────────────────────────────
(function() {
  const head  = document.getElementById('scannerHead');
  const trail = document.getElementById('scannerTrail');
  const scanner = document.getElementById('scanner');
  if (!head || !trail || !scanner) return;

  const HEAD_W = 28, TRAIL_W = 80;
  let pos = 0, dir = 1, lastT = 0;

  const STATE_MAP = {
    'default':        { speed: 0.18, color: '255,0,0'     },
    'listening':      { speed: 0.12, color: '255,100,0'   },
    'speaking':       { speed: 0.45, color: '255,0,0'     },
    'auto-listening': { speed: 0.10, color: '0,200,0'     },
    'auto-hearing':   { speed: 0.40, color: '255,100,0'   },
    'wake-listening': { speed: 0.08, color: '153,51,204'  },
    'wake-hearing':   { speed: 0.38, color: '200,68,255'  },
    'wake-triggered': { speed: 0.55, color: '221,102,255' },
  };

  function getState() {
    const cl = scanner.classList;
    for (const k of ['wake-triggered','wake-hearing','wake-listening',
                      'auto-hearing','auto-listening','speaking','listening'])
      if (cl.contains(k)) return k;
    return 'default';
  }

  function tick(ts) {
    requestAnimationFrame(tick);
    const dt = lastT ? Math.min(ts - lastT, 50) : 16;
    lastT = ts;
    const state = getState();
    let cfg = Object.assign({}, STATE_MAP[state] || STATE_MAP['default']);
    if ((state === 'default' || state === 'speaking') && window._kittEmotionScanColor)
      cfg.color = window._kittEmotionScanColor;

    const maxPx = (scanner.offsetWidth || 300) - HEAD_W;
    pos += dir * cfg.speed * dt;
    if (pos >= maxPx) { pos = maxPx; dir = -1; }
    if (pos <= 0)     { pos = 0;     dir = 1;  }

    head.style.left       = pos + 'px';
    head.style.background = `radial-gradient(ellipse at center,rgba(${cfg.color},1) 0%,rgba(${cfg.color},0.85) 35%,rgba(${cfg.color},0.3) 70%,transparent 100%)`;
    head.style.boxShadow  = `0 0 12px 4px rgba(${cfg.color},0.9),0 0 28px 6px rgba(${cfg.color},0.5),0 0 50px 8px rgba(${cfg.color},0.2)`;

    const trailLeft = dir > 0 ? pos - TRAIL_W : pos + HEAD_W;
    trail.style.left = Math.max(0, trailLeft) + 'px';
    const grad = dir > 0
      ? `linear-gradient(90deg,transparent,rgba(${cfg.color},0.08) 20%,rgba(${cfg.color},0.35) 65%,rgba(${cfg.color},0.75) 100%)`
      : `linear-gradient(270deg,transparent,rgba(${cfg.color},0.08) 20%,rgba(${cfg.color},0.35) 65%,rgba(${cfg.color},0.75) 100%)`;
    trail.style.background = grad;
  }
  requestAnimationFrame(tick);
})();

connectProactive();

// ── Jarvis réactif à la voix KITT ──
(function() {
  const _sw = document.getElementById('sphere-wrap');
  const _js = document.getElementById('jarvis-svg');
  function _tick() {
    if (voiceboxAnalyser && _sw && _js) {
      const d = new Uint8Array(voiceboxAnalyser.frequencyBinCount);
      voiceboxAnalyser.getByteFrequencyData(d);
      const avg = d.reduce((a, b) => a + b, 0) / d.length;
      const t = Math.min(avg / 55, 1); // intensité 0→1
      // Scale de la sphère selon le volume
      const sc = (1 + t * 0.45).toFixed(3);
      _sw.style.transform = `scale(${sc})`;
      // Lueur sur les anneaux HUD (préserve filtre émotion)
      const emF = (_js.dataset.emotionFilter || '');
      _js.style.filter = t > 0.04
        ? `${emF} drop-shadow(0 0 ${(t * 22).toFixed(1)}px rgba(255,50,0,0.85))`.trim()
        : emF;
    }
    requestAnimationFrame(_tick);
  }
  _tick();
})();
</script>
<div class="conn-panel" id="connPanel" aria-hidden="true">
  <div class="cp-title">CONNEXIONS</div>
  <div class="cp-stat"><span class="cp-label">EN LIGNE</span><span class="cp-val" id="cp-current">—</span></div>
  <div class="cp-stat"><span class="cp-label">24H</span><span class="cp-val" id="cp-24h">—</span></div>
  <div class="cp-stat"><span class="cp-label">7 JOURS</span><span class="cp-val" id="cp-7d">—</span></div>
  <div class="cp-sep"></div>
  <div id="cp-sessions"></div>
</div>

<div class="mother-panel" id="motherPanel" aria-hidden="true">
  <div class="mp-header-band">
    <div class="mp-corp">WEYLAND-YUTANI CORP.</div>
    <div class="mp-title">MU-TH-UR 6000</div>
  </div>
  <div class="mp-body">
    <div class="mp-row"><span class="mp-label">STATUS</span><span class="mp-value" id="mp-status">INIT</span></div>
    <div class="mp-row"><span class="mp-label">OPERATEUR</span><span class="mp-value" id="mp-session">—</span></div>
    <div class="mp-row"><span class="mp-label">LANGUE</span><span class="mp-value" id="mp-lang">—</span></div>
    <div class="mp-row"><span class="mp-label">HEURE</span><span class="mp-value" id="mp-time">—</span></div>
    <div class="mp-row"><span class="mp-label">CONNECTES</span><span class="mp-value" id="mp-online-count">—</span></div>
    <div class="mp-sep"></div>
    <div class="mp-mem-title">&#9632; MEMOIRE ACTIVE</div>
    <div id="mp-memory-list"></div>
  </div>
</div>

<div class="footer-credit" onclick="document.getElementById('about').classList.add('visible')">&copy; 2026 ByManix</div>

<div class="name-overlay" id="nameOverlay">
  <div class="name-box">
    <div class="mb-system">MU-TH-UR 6000 · WEYLAND-YUTANI CORP</div>
    <h2 id="mb-title">IDENTIFICATION</h2>
    <div class="mb-sub" id="mb-sub">PROTOCOLE D'ACCES — SYSTEME KYRONEX</div>
    <div class="mb-prompt" id="mb-prompt">ENTREZ VOTRE IDENTIFIANT OPERATEUR :</div>
    <input type="text" id="nameInput" placeholder="Votre prenom" maxlength="30" autocomplete="off" autocorrect="off">
    <div class="lang-selector">
      <button class="lang-opt selected" data-lang="fr" onclick="selectLang('fr')">FR</button>
      <button class="lang-opt" data-lang="en" onclick="selectLang('en')">EN</button>
      <button class="lang-opt" data-lang="de" onclick="selectLang('de')">DE</button>
      <button class="lang-opt" data-lang="it" onclick="selectLang('it')">IT</button>
      <button class="lang-opt" data-lang="es" onclick="selectLang('es')">ES</button>
      <button class="lang-opt" data-lang="pt" onclick="selectLang('pt')">PT</button>
      <button class="lang-opt" data-lang="nl" onclick="selectLang('nl')">NL</button>
    </div>
    <button class="mb-btn" id="mb-btn" onclick="submitName()">INITIER CONNEXION</button>
    <div class="mb-secret-toggle" onclick="toggleSecretPin()">[ ACCES DIRECT ]</div>
    <div class="mb-secret-box" id="mbSecretBox">
      <input type="password" id="secretPin" placeholder="CODE" maxlength="6"
             autocomplete="off" onkeydown="if(event.key==='Enter')checkSecretPin()">
      <button class="mb-secret-btn" onclick="checkSecretPin()">VALIDER</button>
      <div class="mb-secret-msg" id="mbSecretMsg"></div>
    </div>
  </div>
</div>

<!-- ── Visiteurs Overlay ── -->
<div class="rpt-overlay" id="rptOverlay" onclick="if(event.target===this)toggleRptPanel()">
  <div class="rpt-panel" onclick="event.stopPropagation()">
    <div class="rpt-header">
      <span class="rpt-header-title">&#9632; RAPPORT MODE AUTOMATIQUE &mdash; KYRONEX</span>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="rpt-refresh" onclick="_loadAutoReport()">ACTUALISER</button>
        <button class="rpt-close" onclick="toggleRptPanel()">&#10005;</button>
      </div>
    </div>
    <div class="rpt-body" id="rptBody">
      <div class="rpt-loading">Chargement du rapport...</div>
    </div>
  </div>
</div>

<div class="vis-overlay" id="visOverlay" onclick="if(event.target===this)toggleVisPanel()">
  <div class="vis-panel" onclick="event.stopPropagation()">

    <div class="vp-header">
      <span>&#9632; REGISTRE DES VISITEURS &mdash; KYRONEX</span>
      <button class="vp-close" onclick="toggleVisPanel()">&#10005; FERMER</button>
    </div>

    <div class="vp-section">
      <div class="vp-summary">
        <div class="vp-stat">
          <span class="vp-stat-label">EN LIGNE</span>
          <span class="vp-stat-val" id="vp-online">—</span>
        </div>
        <div class="vp-stat">
          <span class="vp-stat-label">VISITEURS UNIQUES</span>
          <span class="vp-stat-val" id="vp-total">—</span>
        </div>
        <div class="vp-stat">
          <span class="vp-stat-label">24 HEURES</span>
          <span class="vp-stat-val" id="vp-24h">—</span>
        </div>
        <div class="vp-stat">
          <span class="vp-stat-label">7 JOURS</span>
          <span class="vp-stat-val" id="vp-7d">—</span>
        </div>
      </div>

      <table class="vp-table">
        <thead>
          <tr>
            <th>NOM</th>
            <th>IP</th>
            <th>MAC</th>
            <th>LANGUE</th>
            <th>PREMIERE VISITE</th>
            <th>DERNIERE VISITE</th>
            <th>VISITES</th>
          </tr>
        </thead>
        <tbody id="vp-tbody">
          <tr><td colspan="7" style="text-align:center;color:#443300;padding:20px">Chargement...</td></tr>
        </tbody>
      </table>
    </div>

    <div class="vp-footer">
      <button class="vp-close" onclick="_visRefresh()">RAFRAICHIR</button>
    </div>

  </div>
</div>

<!-- ── Night Auth Modal ── -->
<div class="night-overlay" id="nightAuthModal" onclick="if(event.target===this)_cancelNightAuth()" style="z-index:600">
  <div class="night-panel" onclick="event.stopPropagation()" style="max-width:340px">
    <div class="np-header">
      <span>&#9632; ACCES RESTREINT</span>
      <button class="np-close" onclick="_cancelNightAuth()">&#10005;</button>
    </div>
    <div class="np-section" style="border-bottom:none;text-align:center;padding:20px 16px">
      <div style="font-size:0.65em;color:#00cc66;letter-spacing:2px;margin-bottom:14px">ENTREZ LE CODE D'ACCES</div>
      <input id="nightAuthInput" type="password" class="np-input"
        placeholder="* * * * * * * * * *"
        style="text-align:center;font-size:1em;letter-spacing:4px;width:100%;margin-bottom:10px"
        onkeydown="if(event.key==='Enter')_submitNightAuth();if(event.key==='Escape')_cancelNightAuth()">
      <div id="nightAuthErr" style="font-size:0.6em;color:#ff4444;letter-spacing:2px;min-height:14px;margin-bottom:10px"></div>
      <div style="display:flex;gap:10px;justify-content:center">
        <button class="np-btn" onclick="_submitNightAuth()" style="padding:6px 20px;font-size:0.7em">VALIDER</button>
        <button class="np-btn danger" onclick="_cancelNightAuth()" style="padding:6px 14px;font-size:0.7em">ANNULER</button>
      </div>
    </div>
  </div>
</div>

<!-- ── Night Scheduler Overlay ── -->
<div class="night-overlay" id="nightOverlay" onclick="if(event.target===this)toggleNightPanel()">
  <div class="night-panel" onclick="event.stopPropagation()">

    <div class="np-header">
      <div>
        <div style="font-size:0.75em;color:#005533;letter-spacing:4px;margin-bottom:2px">MU-TH-UR 6000 &bull; WEYLAND-YUTANI</div>
        <div>&#9632; NIGHT SCHEDULER &mdash; KYRONEX AUTO</div>
      </div>
      <button class="np-close" onclick="toggleNightPanel()">&#10005;</button>
    </div>

    <!-- Daemon status -->
    <div class="np-section">
      <div class="np-label">DAEMON</div>
      <div class="np-daemon-row">
        <span class="np-status-badge off" id="np-badge">&#9675; ARRETE</span>
        <button class="np-btn" id="np-start-btn" onclick="_nightStart()">START</button>
        <button class="np-btn danger" id="np-stop-btn" onclick="_nightStop()" style="display:none">STOP</button>
      </div>
    </div>

    <!-- Fenêtres -->
    <div class="np-section">
      <div class="np-label">MISSIONS PROGRAMMEES</div>
      <div class="np-windows-list" id="np-windows-list">
        <div class="np-empty" id="np-no-windows">Aucune fenetre configuree</div>
      </div>
    </div>

    <!-- Ajouter fenêtre -->
    <div class="np-section">
      <div class="np-label">NOUVELLE MISSION</div>
      <div class="np-form">
        <div class="np-form-row">
          <label>HEURE DEBUT</label>
          <input class="np-input" type="number" id="np-sh" min="0" max="23" value="22">
        </div>
        <div class="np-form-row">
          <label>MIN DEBUT</label>
          <input class="np-input" type="number" id="np-sm" min="0" max="59" value="0">
        </div>
        <div class="np-form-row">
          <label>HEURE FIN</label>
          <input class="np-input" type="number" id="np-eh" min="0" max="23" value="6">
        </div>
        <div class="np-form-row">
          <label>MIN FIN</label>
          <input class="np-input" type="number" id="np-em" min="0" max="59" value="0">
        </div>
        <div class="np-form-row">
          <label>ITERATIONS</label>
          <input class="np-input" type="number" id="np-iter" min="1" max="50" value="10">
        </div>
        <div class="np-form-row">
          <label>DESIGNATION</label>
          <input class="np-input" type="text" id="np-name" placeholder="Mission nocturne" maxlength="30">
        </div>
        <div class="np-days-row">
          <label>JOURS :</label>
          <button class="np-day-btn sel" data-day="1" onclick="_nightToggleDay(this)">LUN</button>
          <button class="np-day-btn sel" data-day="2" onclick="_nightToggleDay(this)">MAR</button>
          <button class="np-day-btn sel" data-day="3" onclick="_nightToggleDay(this)">MER</button>
          <button class="np-day-btn sel" data-day="4" onclick="_nightToggleDay(this)">JEU</button>
          <button class="np-day-btn sel" data-day="5" onclick="_nightToggleDay(this)">VEN</button>
          <button class="np-day-btn sel" data-day="6" onclick="_nightToggleDay(this)">SAM</button>
          <button class="np-day-btn sel" data-day="0" onclick="_nightToggleDay(this)">DIM</button>
        </div>
        <div class="np-days-row" style="grid-column:1/-1">
          <label>CIBLE :</label>
          <button class="np-day-btn sel" id="np-target-interface" onclick="_nightSelectTarget('interface',this)">INTERFACE</button>
          <button class="np-day-btn" id="np-target-site" onclick="_nightSelectTarget('site',this)">SITE GITHUB</button>
        </div>
        <div class="np-form-full">
          <button class="np-btn" onclick="_nightAddWindow()">+ PROGRAMMER</button>
        </div>
      </div>
    </div>

    <!-- Lancer maintenant -->
    <div class="np-section">
      <div class="np-label">LANCER MAINTENANT</div>
      <div class="np-runnow-row">
        <label style="font-size:0.65em;color:#00cc66">ITERATIONS :</label>
        <input class="np-input" type="number" id="np-now-iter" min="1" max="20" value="3" style="width:70px">
        <label style="font-size:0.65em;color:#00cc66">CIBLE :</label>
        <button class="np-day-btn sel" id="np-now-target-interface" onclick="_nightSelectNowTarget('interface',this)">INTERFACE</button>
        <button class="np-day-btn" id="np-now-target-site" onclick="_nightSelectNowTarget('site',this)">SITE GITHUB</button>
        <button class="np-btn" onclick="_nightRunNow()">&#9654; GO</button>
      </div>
    </div>

    <!-- Logs -->
    <div class="np-section">
      <div class="np-label">LOGS</div>
      <div class="np-logs-box" id="np-logs">En attente...</div>
      <div class="np-logs-footer">
        <button class="np-btn" onclick="_nightLoadLogs()">RAFRAICHIR</button>
      </div>
    </div>

    <!-- Téléchargement PDFs -->
    <div class="np-section" style="border-bottom:none">
      <div class="np-label">DOCUMENTATION PDF</div>
      <div id="np-pdf-list" style="display:flex;flex-wrap:wrap;gap:8px;margin-top:6px">
        <span style="font-size:0.6em;color:#336633">Chargement...</span>
      </div>
    </div>

  </div>
</div>

<div class="about-overlay" id="about" onclick="this.classList.remove('visible')">
  <div class="about-box" onclick="event.stopPropagation()">
    <div class="about-title">KITT</div>
    <div class="about-sub">KNIGHT INDUSTRIES TWO THOUSAND</div>
    <div>Intelligence artificielle embarqu&eacute;e<br>By Manix — Propuls&eacute; par KYRONEX</div>
    <div class="about-dev">
      D&eacute;velopp&eacute; par <strong style="color:#aa4444">Emmanuel Gelinne</strong> (Manix)<br>
      Laur&eacute;at concours NVIDIA<br>
      Testeuse officielle : <strong style="color:#aa4444">Virginie Barbay</strong>
    </div>
    <div style="color:#555;font-size:0.75em;margin-top:10px">Technologies : NVIDIA &middot; Jetson Orin Nano &middot; Qwen 2.5</div>
    <div class="about-license">Elastic License 2.0 (ELv2)<br>Tous droits commerciaux r&eacute;serv&eacute;s</div>
    <div class="about-close">Touchez pour fermer</div>
  </div>
</div>

<script>
// ── Authentification Night (code SHA-256, valide pour la session) ────────────
const _NIGHT_HASH = '8c03437292a68baec2fd5374c6adb4d0ddcfc2aade2407fdee2d4f024e423ef3';
let _nightAuthed = false;
let _nightAuthPending = null; // callback en attente

async function _sha256(str) {
  const buf = await crypto.subtle.digest('SHA-256', new TextEncoder().encode(str));
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2,'0')).join('');
}

function _requireNightAuth(callback) {
  if (_nightAuthed) { callback(); return; }
  _nightAuthPending = callback;
  const modal = document.getElementById('nightAuthModal');
  const inp = document.getElementById('nightAuthInput');
  const err = document.getElementById('nightAuthErr');
  inp.value = '';
  err.textContent = '';
  modal.classList.add('visible');
  setTimeout(() => inp.focus(), 80);
}

async function _submitNightAuth() {
  const inp = document.getElementById('nightAuthInput');
  const err = document.getElementById('nightAuthErr');
  const hash = await _sha256(inp.value);
  if (hash === _NIGHT_HASH) {
    _nightAuthed = true;
    document.getElementById('nightAuthModal').classList.remove('visible');
    if (_nightAuthPending) { const cb = _nightAuthPending; _nightAuthPending = null; cb(); }
  } else {
    err.textContent = 'CODE INCORRECT';
    inp.value = '';
    inp.focus();
  }
}

function _cancelNightAuth() {
  _nightAuthPending = null;
  document.getElementById('nightAuthModal').classList.remove('visible');
}

// ── Night Scheduler ───────────────────────────────────────────────────────
let _nightRefreshTimer = null;

function toggleNightPanel() {
  _requireNightAuth(_doToggleNightPanel);
}

function _doToggleNightPanel() {
  const overlay = document.getElementById('nightOverlay');
  const btn = document.getElementById('nightbtn');
  const visible = overlay.classList.toggle('visible');
  btn.classList.toggle('active', visible);
  if (visible) {
    _nightRefresh();
    _nightLoadLogs();
    _nightLoadPdfs();
    _nightRefreshTimer = setInterval(() => _nightRefresh(), 10000);
  } else {
    clearInterval(_nightRefreshTimer);
    _nightRefreshTimer = null;
  }
}

async function _nightLoadPdfs() {
  try {
    const r = await fetch('/api/pdfs');
    const d = await r.json();
    const container = document.getElementById('np-pdf-list');
    if (!d.pdfs || d.pdfs.length === 0) {
      container.innerHTML = '<span style="font-size:0.6em;color:#336633">Aucun PDF disponible.</span>';
      return;
    }
    container.innerHTML = d.pdfs.map(p => {
      const url = '/api/download/' + encodeURIComponent(p.name);
      return '<button onclick="_nightDownloadPdf(\'' + url + '\',\'' + p.name + '\')" ' +
        'style="display:inline-flex;align-items:center;gap:5px;background:#001a0d;border:1px solid #00cc66;' +
        'color:#00ff88;font-family:inherit;font-size:0.62em;letter-spacing:0.5px;padding:5px 10px;' +
        'border-radius:2px;cursor:pointer;" ' +
        'title="Telecharger ' + p.name + '">' +
        '&#11015; ' + p.name + ' (' + p.size_kb + ' Ko)</button>';
    }).join('');
  } catch(e) { console.error('[NIGHT] pdfs error', e); }
}

function _nightDownloadPdf(url, name) {
  _requireNightAuth(() => {
    const a = document.createElement('a');
    a.href = url; a.download = name;
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
  });
}

async function _nightRefresh() {
  try {
    const r = await fetch('/api/scheduler/status');
    const d = await r.json();
    const badge = document.getElementById('np-badge');
    const startBtn = document.getElementById('np-start-btn');
    const stopBtn = document.getElementById('np-stop-btn');
    if (d.active) {
      badge.textContent = '\u25CF ACTIF PID:' + d.pid;
      badge.classList.remove('off');
      startBtn.style.display = 'none';
      stopBtn.style.display = '';
    } else {
      badge.textContent = '\u25CB ARRETE';
      badge.classList.add('off');
      startBtn.style.display = '';
      stopBtn.style.display = 'none';
    }
    _nightRenderWindows(d.windows || []);
  } catch(e) {
    console.error('[NIGHT] status error', e);
  }
}

let _nightSelectedTarget = 'interface';
let _nightNowTarget = 'interface';

function _nightSelectTarget(val, btn) {
  _nightSelectedTarget = val;
  document.getElementById('np-target-interface').classList.toggle('sel', val === 'interface');
  document.getElementById('np-target-site').classList.toggle('sel', val === 'site');
}

function _nightSelectNowTarget(val, btn) {
  _nightNowTarget = val;
  document.getElementById('np-now-target-interface').classList.toggle('sel', val === 'interface');
  document.getElementById('np-now-target-site').classList.toggle('sel', val === 'site');
}

function _nightRenderWindows(windows) {
  const list = document.getElementById('np-windows-list');
  const empty = document.getElementById('np-no-windows');
  const items = list.querySelectorAll('.np-window-item');
  items.forEach(el => el.remove());
  if (windows.length === 0) {
    empty.style.display = '';
    return;
  }
  empty.style.display = 'none';
  const days = ['DIM','LUN','MAR','MER','JEU','VEN','SAM'];
  windows.forEach(w => {
    const div = document.createElement('div');
    div.className = 'np-window-item' + (w.enabled ? '' : ' disabled');
    div.dataset.wid = w.id;
    const daysStr = (w.days || []).map(d => days[d]).join(' ');
    const sh = String(w.start_h).padStart(2,'0') + ':' + String(w.start_m||0).padStart(2,'0');
    const eh = String(w.end_h).padStart(2,'0') + ':' + String(w.end_m||0).padStart(2,'0');
    const targetBadge = w.target === 'site'
      ? '<span style="font-size:0.85em;color:#4488ff;border:1px solid #224488;padding:1px 5px;border-radius:2px">SITE</span>'
      : '<span style="font-size:0.85em;color:#00cc66;border:1px solid #004422;padding:1px 5px;border-radius:2px">UI</span>';
    div.innerHTML =
      '<span class="np-win-name">' + (w.name || 'Fenetre') + '</span>' +
      targetBadge +
      '<span class="np-win-info">' + sh + '&rarr;' + eh + ' &nbsp;' + w.iterations + 'x &nbsp;[' + daysStr + ']</span>' +
      '<button class="np-toggle-btn" onclick="_nightToggleWindow(\'' + w.id + '\')">' + (w.enabled ? 'ON' : 'OFF') + '</button>' +
      '<button class="np-del-btn" onclick="_nightDeleteWindow(\'' + w.id + '\')">&#10005;</button>';
    list.appendChild(div);
  });
}

async function _nightStart() {
  try {
    await fetch('/api/scheduler/start', {method:'POST'});
    await _nightRefresh();
  } catch(e) { console.error('[NIGHT] start error', e); }
}

async function _nightStop() {
  try {
    await fetch('/api/scheduler/stop', {method:'POST'});
    await _nightRefresh();
  } catch(e) { console.error('[NIGHT] stop error', e); }
}

async function _nightAddWindow() {
  const sh = parseInt(document.getElementById('np-sh').value) || 22;
  const sm = parseInt(document.getElementById('np-sm').value) || 0;
  const eh = parseInt(document.getElementById('np-eh').value) || 6;
  const em = parseInt(document.getElementById('np-em').value) || 0;
  const iter = parseInt(document.getElementById('np-iter').value) || 10;
  const name = document.getElementById('np-name').value.trim() || 'Nuit auto';
  const days = Array.from(document.querySelectorAll('#nightOverlay .np-day-btn.sel[data-day]')).map(b => parseInt(b.dataset.day));
  try {
    await fetch('/api/scheduler/window', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({name, start_h:sh, start_m:sm, end_h:eh, end_m:em, iterations:iter, days, target: _nightSelectedTarget})
    });
    await _nightRefresh();
  } catch(e) { console.error('[NIGHT] add window error', e); }
}

function _nightToggleDay(btn) {
  btn.classList.toggle('sel');
}

async function _nightToggleWindow(wid) {
  try {
    await fetch('/api/scheduler/window/' + wid + '/toggle', {method:'POST'});
    await _nightRefresh();
  } catch(e) { console.error('[NIGHT] toggle error', e); }
}

async function _nightDeleteWindow(wid) {
  try {
    await fetch('/api/scheduler/window/' + wid, {method:'DELETE'});
    await _nightRefresh();
  } catch(e) { console.error('[NIGHT] delete error', e); }
}

async function _nightRunNow() {
  const iter = parseInt(document.getElementById('np-now-iter').value) || 3;
  try {
    const r = await fetch('/api/scheduler/run-now', {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({iterations: iter, target: _nightNowTarget})
    });
    const d = await r.json();
    const logs = document.getElementById('np-logs');
    const targetLabel = d.target === 'site' ? 'Site GitHub' : 'Interface KYRONEX';
    logs.textContent = '[GO] ' + targetLabel + ' — PID ' + d.pid + ' — Log: ' + d.log_path + '\nLancement de ' + iter + ' iteration(s)...';
    setTimeout(_nightLoadLogs, 5000);
  } catch(e) { console.error('[NIGHT] run-now error', e); }
}

async function _nightLoadLogs() {
  try {
    const r = await fetch('/api/scheduler/logs');
    const d = await r.json();
    const logs = document.getElementById('np-logs');
    logs.textContent = d.lines.length ? d.lines.join('\n') : 'Aucun log disponible.';
    logs.scrollTop = logs.scrollHeight;
  } catch(e) { console.error('[NIGHT] logs error', e); }
}

// ── Panneau Visiteurs ─────────────────────────────────────────────────────
/* ── Rapport Mode Automatique ── */
function toggleRptPanel() {
  const overlay = document.getElementById('rptOverlay');
  const btn = document.getElementById('rptbtn');
  const visible = overlay.classList.toggle('visible');
  btn.classList.toggle('active', visible);
  if (visible) _loadAutoReport();
}

let _enhanceActive = false;
function toggleEnhance() {
  _enhanceActive = !_enhanceActive;
  const btn = document.getElementById('enhancebtn');
  btn.classList.toggle('active', _enhanceActive);
  document.body.classList.toggle('enhanced', _enhanceActive);
  if (_enhanceActive) {
    _applyUILang(_preferredLang);
    const PH = {
      fr:'Parlez a KITT...',en:'Speak to KITT...',de:'Sprechen Sie mit KITT...',
      it:'Parla con KITT...',pt:'Fale com KITT...',es:'Hable con KITT...',nl:'Spreek met KITT...'
    };
    const input = document.getElementById('input');
    if (input && !input.disabled) input.placeholder = PH[_preferredLang] || PH.fr;
    const statusEl = document.getElementById('status');
    if (statusEl) statusEl.innerHTML = '<span class="online">' + _t('enhance_active') + '</span>';
    setTimeout(() => { if (_enhanceActive) checkHealth(); }, 1500);
  }
}

async function _loadAutoReport() {
  const body = document.getElementById('rptBody');
  body.innerHTML = '<div class="rpt-loading">Chargement...</div>';
  try {
    const r = await fetch('/api/auto-report');
    const d = await r.json();
    body.innerHTML = _renderAutoReport(d);
  } catch(e) {
    body.innerHTML = '<div class="rpt-loading" style="color:#cc4400">Erreur de chargement : ' + e.message + '</div>';
  }
}

function _renderAutoReport(d) {
  const ITER_DESC = {
    v00: 'Sauvegarde initiale (avant session)',
    v01: 'Itération 1 — amélioration appliquée',
    v02: 'Itération 2 — amélioration appliquée',
    v03: 'Itération 3 — amélioration appliquée',
    v04: 'Itération 4', v05: 'Itération 5',
    v06: 'Itération 6', v07: 'Itération 7',
    v08: 'Itération 8', v09: 'Itération 9',
    v10: 'Itération 10', v11: 'Itération 11',
  };
  let html = '';
  // Résumé global
  html += '<div class="rpt-section">';
  html += '<div class="rpt-section-title">RESUME GLOBAL</div>';
  html += '<div class="rpt-row"><span class="rpt-tag">TOTAL</span>';
  html += '<span class="rpt-text"><em>' + d.total_versions + '</em> versions sauvegardées dans static/versions/</span></div>';
  const sessions = d.versions || {};
  const sessionKeys = Object.keys(sessions).sort();
  html += '<div class="rpt-row"><span class="rpt-tag">SESS.</span>';
  html += '<span class="rpt-text"><em>' + sessionKeys.length + '</em> session(s) détectée(s)</span></div>';
  html += '</div>';

  // Détail par session
  if (sessionKeys.length > 0) {
    html += '<div class="rpt-section">';
    html += '<div class="rpt-section-title">VERSIONS PAR SESSION</div>';
    for (const sk of sessionKeys.reverse()) {
      const versions = sessions[sk];
      const successVers = versions.filter(v => v.iter !== 'v00');
      html += '<div style="margin-bottom:12px;padding:8px;border:1px solid #1a2200;border-radius:2px">';
      html += '<div style="color:#ccee44;margin-bottom:6px;font-size:0.9em">Session ' + sk + 'h</div>';
      for (const v of versions) {
        const isBackup = v.iter === 'v00';
        const desc = v.desc || ITER_DESC[v.iter] || v.iter;
        html += '<div class="rpt-row">';
        html += '<span class="rpt-tag' + (isBackup ? '' : ' ok') + '">' + v.iter.toUpperCase() + '</span>';
        html += '<span class="rpt-text">';
        html += '<em>' + v.time + '</em> &mdash; ' + desc;
        html += ' <span class="rpt-meta">(' + v.size_kb + ' KB, ' + v.lines + ' lignes)</span>';
        html += '</span></div>';
      }
      html += '</div>';
    }
    html += '</div>';
  }

  // Logs site improver
  if (d.site_log && d.site_log.length > 0) {
    html += '<div class="rpt-section">';
    html += '<div class="rpt-section-title">LOGS SITE IMPROVER</div>';
    for (const line of d.site_log) {
      const cls = line.includes('SUCCES') ? 'ok' : line.includes('ECHEC') ? 'fail' : '';
      html += '<div class="rpt-log-line ' + cls + '">' + line.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>';
    }
    html += '</div>';
  }

  // Logs night improver
  if (d.night_log && d.night_log.length > 0) {
    html += '<div class="rpt-section">';
    html += '<div class="rpt-section-title">LOGS NIGHT IMPROVER</div>';
    for (const line of d.night_log) {
      const cls = line.includes('SUCCES') ? 'ok' : line.includes('ECHEC') ? 'fail' : '';
      html += '<div class="rpt-log-line ' + cls + '">' + line.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>';
    }
    html += '</div>';
  }

  // Ce que chaque itération a fait (base statique connue)
  html += '<div class="rpt-section">';
  html += '<div class="rpt-section-title">AMELIORATIONS CONNUES (SESSION 2026-02-24)</div>';
  const known = [
    {iter:'v01', time:'04h36', action:'Animations apparition messages', detail:'msgAppear/Left/Right — bulles KITT glissent depuis gauche, user depuis droite. cubic-bezier 0.25→0.46, scale 0.97→1, compatible Safari.'},
    {iter:'v02', time:'04h39', action:'Bouton SEND pulse pendant envoi', detail:'Classe .sending sur #send — fond rouge pulsant @kitt-send-pulse, cursor:wait. Retiré automatiquement après réponse.'},
    {iter:'v03', time:'04h40', action:'Zone tactile mobile 44px + PDF', detail:'::before sur RST/AMB/VIG/NIGHT pour cibles tactiles élargies. Section DOCUMENTATION PDF dans panneau nuit.'},
    {iter:'v04', time:'', action:'Scanner sweep input focus', detail:'::after sur .input-area — lueur rouge balaie la ligne du haut (left→right, 2.2s linear) dès focus-within. Glow box-shadow -4px haut.'},
  ];
  for (const k of known) {
    html += '<div style="margin-bottom:10px;padding:8px;border-left:2px solid #334400">';
    html += '<div class="rpt-row"><span class="rpt-tag ok">' + k.iter.toUpperCase() + '</span>';
    html += '<span class="rpt-text"><em>' + k.time + '</em> &mdash; ' + k.action + '</span></div>';
    html += '<div style="color:#556600;margin-left:52px;margin-top:2px">' + k.detail + '</div>';
    html += '</div>';
  }
  html += '</div>';

  return html;
}

function toggleVisPanel() {
  _requireNightAuth(_doToggleVisPanel);
}

function _doToggleVisPanel() {
  const overlay = document.getElementById('visOverlay');
  const btn = document.getElementById('visbtn');
  const visible = overlay.classList.toggle('visible');
  btn.classList.toggle('active', visible);
  if (visible) _visRefresh();
}

async function _visRefresh() {
  try {
    const [rv, rs] = await Promise.all([
      fetch('/api/visitors'),
      fetch('/api/stats')
    ]);
    const vd = await rv.json();
    const sd = await rs.json();
    document.getElementById('vp-online').textContent = sd.current ?? '—';
    document.getElementById('vp-24h').textContent = sd.last_24h ?? '—';
    document.getElementById('vp-7d').textContent = sd.last_7d ?? '—';
    document.getElementById('vp-total').textContent = vd.total ?? '—';
    const tbody = document.getElementById('vp-tbody');
    const activeSids = new Set((sd.active_sessions || []).map(s => s.ip));
    if (!vd.visitors || vd.visitors.length === 0) {
      tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;color:#443300;padding:20px">Aucun visiteur enregistre.</td></tr>';
      return;
    }
    tbody.innerHTML = vd.visitors.map(v => {
      const online = activeSids.has(v.ip)
        ? '<span class="vp-badge-online"></span>' : '';
      const mac = v.mac && v.mac !== v.ip ? v.mac : '—';
      const lang = v.lang && v.lang !== '?' ? v.lang.toUpperCase() : '—';
      return '<tr>' +
        '<td class="vp-name">' + online + (v.name || '?') + '</td>' +
        '<td class="vp-ip">' + (v.ip || '—') + '</td>' +
        '<td class="vp-mac">' + mac + '</td>' +
        '<td class="vp-lang">' + lang + '</td>' +
        '<td>' + (v.first_seen_fmt || '—') + '</td>' +
        '<td>' + (v.last_seen_fmt || '—') + '</td>' +
        '<td class="vp-visits">' + (v.visits || 0) + '</td>' +
        '</tr>';
    }).join('');
  } catch(e) { console.error('[VIS] refresh error', e); }
}

// ── Skip identification — code PIN ────────────────────────────────────────
let _secretAttempts = 0;
function toggleSecretPin() {
  const box = document.getElementById('mbSecretBox');
  const show = box.style.display !== 'block';
  box.style.display = show ? 'block' : 'none';
  if (show) setTimeout(() => document.getElementById('secretPin').focus(), 50);
}
function checkSecretPin() {
  const pin = document.getElementById('secretPin').value.trim();
  const msg = document.getElementById('mbSecretMsg');
  if (pin === '5505') {
    msg.style.color = '#44ff88';
    msg.textContent = '[ ACCES AUTORISE ]';
    const ov = document.getElementById('nameOverlay');
    ov.style.transition = 'opacity 0.4s';
    ov.style.opacity = '0';
    setTimeout(() => {
      ov.classList.remove('visible');
      ov.style.opacity = ''; ov.style.transition = '';
    }, 400);
    unlockUI('Manix', 'fr');
  } else {
    _secretAttempts++;
    msg.style.color = '#cc3333';
    msg.textContent = '[ CODE INCORRECT ]';
    document.getElementById('secretPin').value = '';
    const nb = document.querySelector('.name-box');
    nb.classList.add('mb-shake');
    setTimeout(() => nb.classList.remove('mb-shake'), 400);
    if (_secretAttempts >= 3) {
      setTimeout(() => { toggleSecretPin(); _secretAttempts = 0; }, 800);
    }
  }
}

// ── Téléchargement index.html ─────────────────────────────────────────────
function downloadHtml() {
  window.location.href = '/api/download-html';
}

// ── Git push index.html → GitHub ──────────────────────────────────────────
async function gitPushHtml() {
  const btn = document.getElementById('gitbtn');
  btn.classList.add('pushing'); btn.textContent = '...';
  try {
    const r = await fetch('/api/git-push-html', {method:'POST'});
    const d = await r.json();
    btn.textContent = d.ok ? 'OK' : 'ERR';
    btn.style.color = d.ok ? '#44ff88' : '#ff4444';
    setTimeout(() => { btn.textContent = 'GIT'; btn.classList.remove('pushing'); btn.style.color = ''; }, 2500);
  } catch(e) {
    btn.textContent = 'ERR'; setTimeout(() => { btn.textContent = 'GIT'; btn.classList.remove('pushing'); }, 2500);
  }
}

// ── Lancer amélioration autonome maintenant ────────────────────────────────
async function runImprove() {
  const btn = document.getElementById('runbtn');
  btn.classList.add('running'); btn.textContent = '...';
  try {
    const r = await fetch('/api/scheduler/run-now', {method:'POST'});
    const d = await r.json();
    btn.textContent = d.ok ? 'OK' : 'ERR';
    btn.style.color = d.ok ? '#ffaa44' : '#ff4444';
    setTimeout(() => { btn.textContent = 'RUN'; btn.classList.remove('running'); btn.style.color = ''; }, 3000);
  } catch(e) {
    btn.textContent = 'ERR'; setTimeout(() => { btn.textContent = 'RUN'; btn.classList.remove('running'); }, 3000);
  }
}

// ── Protection bouton RST ─────────────────────────────────────────────────
const _origResetChat = typeof resetChat === 'function' ? resetChat : null;
document.addEventListener('DOMContentLoaded', () => {
  const rstBtn = document.getElementById('resetbtn');
  if (rstBtn) {
    rstBtn.onclick = () => _requireNightAuth(() => {
      if (_origResetChat) _origResetChat();
    });
  }
});
</script>
</body>
</html>
